 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/main_window.py b/main_window.py
index 6ad10d08176f8cb6fc89ec1774bfe5207d393838..1dad81ed52eb4625c85996b453e65cec8d475b00 100644
--- a/main_window.py
+++ b/main_window.py
@@ -3692,115 +3692,65 @@ class MainWindow(QMainWindow):
             text_value = text_value.strip()
         if text_value:
             return str(text_value)
         return None
 
     def _is_time_only_result(self, text):
         if not text:
             return False
         cleaned = str(text).strip()
         return bool(re.fullmatch(r"\d{1,2}:\d{2}(?::\d{2})?", cleaned))
 
     def buildResultSummary(self, detail, detail_text=None):
         if not isinstance(detail, dict):
             return "Resultado no registrado"
 
         def pick_summary(value):
             if value is None:
                 return None
             cleaned = str(value).strip()
             if not cleaned:
                 return None
             if self._is_time_only_result(cleaned):
                 return None
             return cleaned
 
-        def normalize_qualitative(text):
-            if not text:
-                return None
-            normalized = self._normalize_text(text)
-            if "no react" in normalized or "noreact" in normalized:
-                return "No reactivo"
-            if "reactiv" in normalized:
-                return "Reactivo"
-            if "positiv" in normalized:
-                return "Positivo"
-            if "negativ" in normalized:
-                return "Negativo"
-            return None
-
-        def extract_unit(text):
-            if not isinstance(text, str):
-                return None
-            match = re.search(r"-?\d+(?:[.,]\d+)?\s*([^\d\s].*)", text.strip())
-            if match:
-                return match.group(1).strip()
-            return None
-
         test_name = detail.get("test") or ""
         raw_result = detail.get("raw_result")
-        observation = detail.get("observation")
 
         summary_text = pick_summary(self._build_exam_result_summary(test_name, raw_result))
         if summary_text:
             return summary_text
 
         parsed = self._parse_stored_result(raw_result)
         text_value = parsed.get("value", raw_result or "")
         if isinstance(text_value, str):
             text_value = text_value.strip()
 
-        qualitative = normalize_qualitative(text_value) or normalize_qualitative(observation)
-        if qualitative:
-            return qualitative
-
-        numeric_value = self._extract_numeric_value(text_value)
-        if numeric_value is not None:
-            formatted_value = self._format_decimal(numeric_value)
-            unit = extract_unit(text_value)
-            if not unit:
-                template = TEST_TEMPLATES.get(test_name)
-                if template:
-                    fields = [field for field in template.get("fields", []) if field.get("key") and field.get("type") != "section"]
-                    if len(fields) == 1:
-                        unit = fields[0].get("unit")
-            abbr = self._abbreviate_exam_name(test_name)
-            unit_text = f" {unit}" if unit else ""
-            return f"{abbr} {formatted_value}{unit_text}".strip()
-
-        if text_value:
+        if text_value and not self._is_time_only_result(text_value):
             return str(text_value)
 
-        summary_text = pick_summary(observation)
-        if summary_text:
-            return summary_text
-
-        if detail_text:
-            detail_line = pick_summary(detail_text.splitlines()[0])
-            if detail_line:
-                return detail_line
-
         return "Resultado no registrado"
 
     def _build_exam_detail_text(self, test_name, raw_result, context=None, observation=None, issue=None, cancel_reason=None):
         lines = self._format_result_lines(test_name, raw_result, context=context)
         detail_lines = []
         for line in lines:
             cleaned = line.strip()
             if not cleaned:
                 continue
             detail_lines.append(cleaned)
         if issue:
             detail_lines.append(f"Notas: {issue}")
         if cancel_reason:
             detail_lines.append(f"Motivo de anulaciÃ³n: {cancel_reason}")
         if observation:
             detail_lines.append(f"Observaciones: {observation}")
         return "\n".join(detail_lines)
 
     def _post_process_registry_pairs(self, pairs):
         if not pairs:
             return []
         processed = list(pairs)
         processed = self._ensure_hematocrit_pair(processed)
         return processed
 
 
EOF
)