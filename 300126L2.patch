 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/main_window.py b/main_window.py
index 39171b13d3a4555e9adfdb2d184687144ffb4372..78d65df74685abfe0bb0e4156fbf02d61134ea02 100644
--- a/main_window.py
+++ b/main_window.py
@@ -3857,92 +3857,96 @@ class MainWindow(QMainWindow):
                     "gestational_age_weeks": record.get("gestational_age_weeks"),
                     "expected_delivery_date": record.get("expected_delivery_date"),
                     "age": record.get("age", ""),
                     "first_name": record.get("first_name"),
                     "last_name": record.get("last_name"),
                     "observations": record.get("order_observations"),
                     "requested_by": record.get("requested_by"),
                     "insurance_type": record.get("insurance_type"),
                     "fua_number": record.get("fua_number"),
                     "emitted": record.get("emitted"),
                     "emitted_at": record.get("emitted_at"),
                     "groups": {key: [] for key in group_keys},
                     "tests": [],
                     "sample_statuses": [],
                     "pending_tests": [],
                     "test_detail_map": OrderedDict()
                 }
                 grouped[order_id] = entry
             group_key = self._map_category_group(record.get("category"))
             if has_result:
                 for item in summary_items:
                     cleaned = str(item).strip()
                     if cleaned:
                         entry["groups"].setdefault(group_key, []).append(cleaned)
             test_name = record.get("test")
+            test_id = record.get("test_id")
             if test_name:
                 test_clean = str(test_name).strip()
                 if test_clean and test_clean not in entry.setdefault("tests", []):
                     entry["tests"].append(test_clean)
+                detail_key = test_id if test_id not in (None, "") else test_clean
                 detail_map = entry.setdefault("test_detail_map", OrderedDict())
-                detail_entry = detail_map.get(test_clean, {
+                detail_entry = detail_map.get(detail_key, {
                     "test": test_clean,
+                    "test_id": test_id,
                     "group": group_key,
                     "summary_items": [],
                     "summary_text": None,
                     "has_result": False,
                     "sample_received": False,
                     "sample_status": None,
                     "is_cancelled": False,
                     "cancel_reason": None,
                     "is_emitted": False,
                     "issue": None,
                     "is_critical": False,
                     "observation": None,
                     "raw_result": None,
                     "pending_since": None,
                     "order_date_raw": None,
                     "sample_date_raw": None
                 })
                 if summary_items and has_result:
                     detail_entry["summary_items"] = summary_items
                 if summary_text and has_result:
                     detail_entry["summary_text"] = summary_text
                 detail_entry["has_result"] = detail_entry["has_result"] or has_result
                 detail_entry["sample_received"] = detail_entry["sample_received"] or sample_received
                 detail_entry["sample_status"] = record.get("sample_status") or detail_entry.get("sample_status")
                 detail_entry["is_cancelled"] = detail_entry.get("is_cancelled") or bool(record.get("is_cancelled"))
                 detail_entry["cancel_reason"] = record.get("cancel_reason") or detail_entry.get("cancel_reason")
                 detail_entry["is_emitted"] = detail_entry.get("is_emitted") or bool(record.get("emitted"))
                 detail_entry["issue"] = record.get("sample_issue") or detail_entry.get("issue")
                 detail_entry["is_critical"] = detail_entry["is_critical"] or bool(record.get("is_critical"))
                 detail_entry["observation"] = record.get("observation") or detail_entry.get("observation")
                 detail_entry["raw_result"] = record.get("raw_result") or detail_entry.get("raw_result")
                 detail_entry["pending_since"] = record.get("pending_since") or detail_entry.get("pending_since")
                 detail_entry["order_date_raw"] = record.get("order_date_raw") or detail_entry.get("order_date_raw")
                 detail_entry["sample_date_raw"] = record.get("sample_date_raw") or detail_entry.get("sample_date_raw")
-                detail_map[test_clean] = detail_entry
+                detail_entry["test_id"] = detail_entry.get("test_id") or test_id
+                detail_map[detail_key] = detail_entry
             if sample_received and not has_result and test_name:
                 entry.setdefault("pending_tests", []).append(test_name)
             status_info = {
                 "test": record.get("test"),
                 "status": record.get("sample_status"),
                 "issue": record.get("sample_issue"),
                 "pending_since": record.get("pending_since"),
             }
             entry.setdefault("sample_statuses", []).append(status_info)
         for entry in grouped.values():
             obs_text = entry.get("observations")
             if obs_text:
                 obs_clean = " ".join(str(obs_text).split())
                 if obs_clean and obs_clean.lower() not in {"n/a", "na", "-"}:
                     entry["groups"].setdefault("others", []).append(f"Obs: {obs_clean}")
             if "test_detail_map" in entry:
                 entry["test_details"] = list(entry["test_detail_map"].values())
             if entry.get("test_detail_map"):
                 aggregated.append(entry)
         return aggregated
 
     def _format_short_date(self, value):
         return self._format_date_display(value, "—")
 
     def _format_patient_block_for_registry(self, entry):
@@ -4303,82 +4307,90 @@ class MainWindow(QMainWindow):
             return False
         return self._segment_matches_sex(sexes, normalized_sex)
 
     def _age_in_range(self, age_value, start, end):
         if start is None and end is None:
             return True
         if start is None:
             return age_value <= end
         if end is None:
             return age_value >= start
         return start <= age_value <= end
 
     def _segment_matches_sex(self, sexes, normalized_sex):
         if not sexes:
             return True
         if not normalized_sex:
             return True
         if any(keyword in normalized_sex for keyword in ["femen", "mujer"]):
             return 'female' in sexes
         if any(keyword in normalized_sex for keyword in ["mascul", "hombre", "varon"]):
             return 'male' in sexes
         return True
     def _extract_result_structure(self, test_name, raw_result, context=None):
         parsed = self._parse_stored_result(raw_result)
         template_key = parsed.get("template") if isinstance(parsed, dict) else None
-        template = TEST_TEMPLATES.get(template_key) if template_key in TEST_TEMPLATES else TEST_TEMPLATES.get(test_name)
+        template = None
+        if template_key and template_key in TEST_TEMPLATES:
+            template = TEST_TEMPLATES.get(template_key)
+        elif template_key == "Hematocrito (automático)" and template_key not in TEST_TEMPLATES:
+            TEST_TEMPLATES[template_key] = build_hematocrit_template(include_auto_hemoglobin=True)
+            template = TEST_TEMPLATES.get(template_key)
+        if template is None:
+            template = TEST_TEMPLATES.get(test_name)
         effective_context = context or self.current_order_context
         if parsed.get("type") == "structured" and template:
             values = parsed.get("values", {})
             items = []
             pending_section = None
             for field_def in template.get("fields", []):
                 if field_def.get("type") == "section":
                     pending_section = field_def.get("label", "") or None
                     continue
                 key = field_def.get("key")
                 if not key:
                     continue
                 value = values.get(key, "")
                 if isinstance(value, str):
                     stripped = value.strip()
                     if stripped == "":
                         continue
                     display_value = " ".join(value.split())
                 else:
                     if self._is_blank_result(value):
                         continue
                     display_value = value
                 unit = field_def.get("unit")
                 field_type = field_def.get("type")
                 if unit and field_type not in ("bool", "text_area", "choice"):
                     display_value = f"{display_value} {unit}" if not str(display_value).endswith(unit) else display_value
                 if pending_section:
                     items.append({"type": "section", "label": pending_section})
                     pending_section = None
                 items.append({
                     "type": "value",
+                    "key": key,
                     "label": field_def.get("label", key),
                     "value": display_value,
                     "reference": self._get_field_reference(field_def, effective_context)
                 })
             return {"type": "structured", "items": items}
         text_value = parsed.get("value", raw_result or "")
         if isinstance(text_value, str):
             text_value = text_value.strip()
             if text_value == "":
                 return {"type": "text", "value": ""}
         elif self._is_blank_result(text_value):
             return {"type": "text", "value": ""}
         return {"type": "text", "value": text_value}
     def _find_logo_path(self, position):
         if position not in {"left", "center", "right"}:
             return None
         search_dirs = ["", "assets", "resources", "images", "img", "static"]
         base_names = [
             f"logo_{position}.png",
             f"logo_{position}.jpg",
             f"logo_{position}.jpeg",
             f"{position}_logo.png",
             f"{position}_logo.jpg",
         ]
         if position == "center":
@@ -5431,61 +5443,56 @@ class MainWindow(QMainWindow):
         self.history_fua_btn = QToolButton()
         self.history_fua_btn.setToolTip("Registrar FUA")
         self.history_fua_btn.setIcon(self.style().standardIcon(QStyle.SP_FileDialogNewFolder))
         self.history_fua_btn.setEnabled(False)
         self.history_window_btn = QToolButton()
         self.history_window_btn.setToolTip("Ventana de historial")
         self.history_window_btn.setIcon(self.style().standardIcon(QStyle.SP_TitleBarMaxButton))
         self.history_window_btn.setEnabled(False)
         for btn in (self.history_open_btn, self.history_fua_btn, self.history_window_btn):
             btn.setToolButtonStyle(Qt.ToolButtonIconOnly)
         history_toolbar_layout.addWidget(self.history_open_btn)
         history_toolbar_layout.addWidget(self.history_fua_btn)
         history_toolbar_layout.addWidget(self.history_window_btn)
         history_toolbar_layout.addStretch()
         history_tab_layout.addLayout(history_toolbar_layout)
 
         self.history_tab = history_tab
         self.history_alerts_bar = QFrame()
         self.history_alerts_bar.setObjectName("HistoryAlertsBar")
         alerts_bar_layout = QHBoxLayout(self.history_alerts_bar)
         alerts_bar_layout.setContentsMargins(12, 6, 12, 6)
         alerts_bar_layout.setSpacing(10)
         alerts_bar_label = QLabel("Alertas clínicas:")
         alerts_bar_label.setStyleSheet("font-weight: 700; color: #1f2d3d;")
         alerts_bar_layout.addWidget(alerts_bar_label)
-        self.history_alerts_bar_scroll = QScrollArea()
-        self.history_alerts_bar_scroll.setFrameShape(QFrame.NoFrame)
-        self.history_alerts_bar_scroll.setWidgetResizable(True)
-        self.history_alerts_bar_scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)
-        self.history_alerts_bar_scroll.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
         self.history_alerts_bar_container = QWidget()
-        self.history_alerts_bar_layout = QHBoxLayout(self.history_alerts_bar_container)
+        self.history_alerts_bar_layout = QGridLayout(self.history_alerts_bar_container)
         self.history_alerts_bar_layout.setContentsMargins(0, 0, 0, 0)
-        self.history_alerts_bar_layout.setSpacing(6)
-        self.history_alerts_bar_scroll.setWidget(self.history_alerts_bar_container)
-        alerts_bar_layout.addWidget(self.history_alerts_bar_scroll, 1)
+        self.history_alerts_bar_layout.setHorizontalSpacing(6)
+        self.history_alerts_bar_layout.setVerticalSpacing(4)
+        alerts_bar_layout.addWidget(self.history_alerts_bar_container, 1)
         self.history_alerts_bar.setVisible(False)
         history_workspace = QWidget()
         self.history_workspace = history_workspace
         self.history_workspace_layout = QGridLayout(history_workspace)
         self.history_workspace_layout.setContentsMargins(0, 0, 0, 0)
         self.history_workspace_layout.setSpacing(8)
 
         self.history_orders_panel = QGroupBox("Historial de órdenes")
         orders_layout = QVBoxLayout(self.history_orders_panel)
         orders_layout.setSpacing(4)
         history_search_layout = QHBoxLayout()
         history_search_layout.addWidget(QLabel("DNI:"))
         self.history_doc_input = QLineEdit()
         self.history_doc_input.setPlaceholderText("Ingrese DNI")
         history_search_layout.addWidget(self.history_doc_input)
         history_search_layout.addWidget(QLabel("Apellidos:"))
         self.history_lastname_input = QLineEdit()
         self.history_lastname_input.setPlaceholderText("Ej. PEREZ / PEREZ GARCIA")
         history_search_layout.addWidget(self.history_lastname_input)
         self.history_search_btn = QToolButton()
         self.history_search_btn.setToolTip("Buscar")
         self.history_search_btn.setIcon(self.style().standardIcon(QStyle.SP_FileDialogContentsView))
         history_search_layout.addWidget(self.history_search_btn)
         history_search_layout.addStretch()
         orders_layout.addLayout(history_search_layout)
@@ -5517,136 +5524,124 @@ class MainWindow(QMainWindow):
         self.history_table.setAlternatingRowColors(True)
         self.history_table.setWordWrap(True)
         self.history_table.verticalHeader().setVisible(False)
         self.history_table.horizontalHeader().setStretchLastSection(True)
         self.history_table.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
         self.history_headers = history_headers
         self.history_column_map = {header: idx for idx, header in enumerate(history_headers)}
         orders_layout.addWidget(self.history_table)
 
         self.history_patient_panel = QGroupBox("Resumen clínico del paciente")
         patient_layout = QVBoxLayout(self.history_patient_panel)
         self.history_patient_summary_label = QLabel()
         self.history_patient_summary_label.setWordWrap(True)
         self.history_patient_summary_label.setTextFormat(Qt.RichText)
         self.history_patient_summary_label.setStyleSheet("QLabel { padding: 4px; }")
         patient_scroll = QScrollArea()
         patient_scroll.setWidgetResizable(True)
         patient_scroll.setFrameShape(QFrame.NoFrame)
         patient_container = QWidget()
         patient_container_layout = QVBoxLayout(patient_container)
         patient_container_layout.setContentsMargins(0, 0, 0, 0)
         patient_container_layout.addWidget(self.history_patient_summary_label)
         patient_scroll.setWidget(patient_container)
         patient_layout.addWidget(patient_scroll)
 
-        self.history_alerts_panel = QGroupBox("Alertas clínicas")
-        alerts_layout = QVBoxLayout(self.history_alerts_panel)
-        alerts_layout.setContentsMargins(6, 6, 6, 6)
-        alerts_layout.setSpacing(4)
-        self.history_alerts_placeholder = QLabel("Sin alertas registradas.")
-        self.history_alerts_placeholder.setStyleSheet("color: #666; padding: 6px;")
-        self.history_alerts_container = QWidget()
-        self.history_alerts_grid = QGridLayout(self.history_alerts_container)
-        self.history_alerts_grid.setContentsMargins(6, 6, 6, 6)
-        self.history_alerts_grid.setHorizontalSpacing(6)
-        self.history_alerts_grid.setVerticalSpacing(6)
-        alerts_scroll = QScrollArea()
-        alerts_scroll.setWidgetResizable(True)
-        alerts_scroll.setFrameShape(QFrame.NoFrame)
-        alerts_scroll.setWidget(self.history_alerts_container)
-        alerts_layout.addWidget(self.history_alerts_placeholder)
-        alerts_layout.addWidget(alerts_scroll)
         self.history_has_alerts = False
 
         self.history_detail_panel = QGroupBox("Detalle de la orden / Exámenes")
         detail_layout = QVBoxLayout(self.history_detail_panel)
         self.history_detail_empty = QLabel("Sin exámenes registrados en esta orden.")
         self.history_detail_empty.setAlignment(Qt.AlignCenter)
         self.history_detail_empty.setStyleSheet("color: #666; padding: 12px;")
         self.history_detail_tree = QTreeWidget()
         self.history_detail_tree.setHeaderLabels(["Examen", "Parámetro", "Resultado"])
         self.history_detail_tree.setRootIsDecorated(False)
         self.history_detail_tree.setAlternatingRowColors(True)
         self.history_detail_tree.setItemsExpandable(True)
         self.history_detail_tree.setUniformRowHeights(False)
         self.history_detail_tree.setTextElideMode(Qt.ElideNone)
         header = self.history_detail_tree.header()
         header.setSectionResizeMode(0, QHeaderView.ResizeToContents)
         header.setSectionResizeMode(1, QHeaderView.ResizeToContents)
         header.setSectionResizeMode(2, QHeaderView.Stretch)
         self.history_detail_tree.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
         self.history_detail_tree.itemClicked.connect(self._toggle_history_detail_item)
         detail_layout.addWidget(self.history_detail_empty)
         detail_layout.addWidget(self.history_detail_tree)
 
         self.history_combined_panel = QFrame()
         self.history_combined_panel.setFrameShape(QFrame.NoFrame)
         combined_layout = QVBoxLayout(self.history_combined_panel)
         combined_layout.setContentsMargins(0, 0, 0, 0)
         combined_layout.setSpacing(8)
-        combined_layout.addWidget(self.history_alerts_panel)
         combined_layout.addWidget(self.history_detail_panel)
         self.history_combined_layout = combined_layout
 
         self.history_mobile_toolbox = QToolBox()
 
+        history_tab_layout.addWidget(self.history_alerts_bar)
         history_tab_layout.addWidget(history_workspace)
         history_tab_layout.addWidget(self.history_mobile_toolbox)
         self.history_mobile_toolbox.hide()
         self.analysis_tabs.addTab(history_tab, "Historial de pacientes")
         self._stats_controls_ready = False
         self.stats_mode_combo.currentIndexChanged.connect(self._update_stats_period_controls)
         self.stats_month_combo.currentIndexChanged.connect(lambda _: self.refresh_statistics())
         self.stats_quarter_combo.currentIndexChanged.connect(lambda _: self.refresh_statistics())
         self.stats_year_spin.valueChanged.connect(lambda _: self.refresh_statistics())
         self._history_results = []
         self.range_combo.currentIndexChanged.connect(self._update_range_controls)
         self.activity_search_input.textChanged.connect(self.apply_activity_filter)
         self.view_activity_btn.clicked.connect(self.load_activity_summary)
         self.export_activity_pdf_btn.clicked.connect(lambda: self.export_activity_record("pdf"))
         self.export_activity_csv_btn.clicked.connect(lambda: self.export_activity_record("csv"))
         self.export_activity_excel_btn.clicked.connect(lambda: self.export_activity_record("xlsx"))
         self.export_activity_delivery_btn.clicked.connect(self.export_activity_delivery_sheet)
         self.delete_activity_btn.clicked.connect(self.delete_selected_activity_entries)
         self.activity_min_age_spin.valueChanged.connect(self.apply_activity_filter)
         self.activity_max_age_spin.valueChanged.connect(self.apply_activity_filter)
         self.activity_test_filter.currentIndexChanged.connect(self.apply_activity_filter)
         self._update_range_controls()
         self._stats_controls_ready = True
         self._update_stats_period_controls()
         self.history_doc_input.returnPressed.connect(self.search_patient_history)
         self.history_lastname_input.returnPressed.connect(self.search_patient_history)
         self.history_search_btn.clicked.connect(self.search_patient_history)
         self.history_open_btn.clicked.connect(self.open_history_order_from_analysis)
         self.history_table.itemSelectionChanged.connect(self._on_history_selection_changed)
         self.history_fua_btn.clicked.connect(self.edit_history_fua)
         self.history_window_btn.clicked.connect(self.open_history_window)
         if hasattr(self, 'history_tab'):
             def _history_tab_resize(event):
                 QWidget.resizeEvent(self.history_tab, event)
                 self._update_history_workspace_layout()
+                if hasattr(self, '_history_alert_tags'):
+                    self._layout_history_alerts_bar(
+                        self._history_alert_tags,
+                        getattr(self, '_history_alert_color_map', None)
+                    )
             self.history_tab.resizeEvent = _history_tab_resize
         self._update_history_workspace_layout()
     def refresh_statistics(self):
         if not getattr(self, '_stats_controls_ready', False):
             return
         period = self._get_statistics_period()
         start_dt = datetime.datetime.combine(period['start'], datetime.time(0, 0, 0))
         end_dt = datetime.datetime.combine(period['end'], datetime.time(23, 59, 59))
         stats = self.labdb.get_statistics(start_dt.isoformat(sep=' '), end_dt.isoformat(sep=' '))
         summary_lines = [
             f"Período: {period['label']}",
             f"Pacientes atendidos: {stats['total_patients']}",
             f"Órdenes realizadas: {stats['total_orders']}",
             f"Pruebas realizadas: {stats['total_tests_conducted']}"
         ]
         self.stats_label.setText("\n".join(summary_lines))
         self.stats_table.setRowCount(0)
         detail = stats.get('by_category_detail', OrderedDict())
         ordered_categories = [cat for cat in CATEGORY_DISPLAY_ORDER if cat in detail]
         remaining = [cat for cat in detail.keys() if cat not in ordered_categories]
         categories = ordered_categories + remaining
         header_font = QFont()
         header_font.setBold(True)
         highlight_color = QColor(230, 242, 235)
         for category in categories:
@@ -6423,89 +6418,78 @@ class MainWindow(QMainWindow):
         pdf.set_auto_page_break(prev_auto, margin=prev_bottom)
 
     def _clear_history_table(self):
         if hasattr(self, 'history_table'):
             self.history_table.setRowCount(0)
         self._history_results = []
         if hasattr(self, 'history_open_btn'):
             self.history_open_btn.setEnabled(False)
         if hasattr(self, 'history_window_btn'):
             self.history_window_btn.setEnabled(False)
         self._render_history_preview(None)
 
     def _clear_layout(self, layout):
         if not layout:
             return
         while layout.count():
             item = layout.takeAt(0)
             widget = item.widget()
             if widget:
                 widget.setParent(None)
 
     def _update_history_workspace_layout(self):
         if not hasattr(self, 'history_tab') or not hasattr(self, 'history_workspace_layout'):
             return
         width = self.history_tab.width()
-        has_alerts = bool(getattr(self, 'history_has_alerts', False))
         if width < 980:
-            if hasattr(self, 'history_alerts_bar'):
-                self.history_alerts_bar.hide()
             self.history_workspace.hide()
             self.history_mobile_toolbox.show()
             self._clear_layout(self.history_workspace_layout)
             while self.history_mobile_toolbox.count() > 0:
                 widget = self.history_mobile_toolbox.widget(0)
                 self.history_mobile_toolbox.removeItem(0)
                 if widget:
                     widget.setParent(None)
             self.history_mobile_toolbox.addItem(self.history_orders_panel, "Historial")
             self.history_mobile_toolbox.addItem(self.history_patient_panel, "Paciente")
-            if has_alerts:
-                self.history_mobile_toolbox.addItem(self.history_alerts_panel, "Alertas")
             self.history_mobile_toolbox.addItem(self.history_detail_panel, "Detalle de orden")
             return
         self.history_mobile_toolbox.hide()
         self.history_workspace.show()
         while self.history_mobile_toolbox.count() > 0:
             widget = self.history_mobile_toolbox.widget(0)
             self.history_mobile_toolbox.removeItem(0)
             if widget:
                 widget.setParent(None)
         self._clear_layout(self.history_workspace_layout)
-        row_offset = 1 if has_alerts else 0
-        if has_alerts and hasattr(self, 'history_alerts_bar'):
-            self.history_alerts_bar.show()
-            self.history_workspace_layout.addWidget(self.history_alerts_bar, 0, 1, 1, 2)
-        elif hasattr(self, 'history_alerts_bar'):
-            self.history_alerts_bar.hide()
-        self.history_workspace_layout.addWidget(self.history_orders_panel, row_offset, 0)
-        self.history_workspace_layout.addWidget(self.history_patient_panel, row_offset, 1)
-        self.history_workspace_layout.addWidget(self.history_detail_panel, row_offset, 2)
+        self.history_workspace_layout.addWidget(self.history_orders_panel, 0, 0)
+        self.history_workspace_layout.addWidget(self.history_patient_panel, 0, 1)
+        self.history_workspace_layout.addWidget(self.history_detail_panel, 0, 2)
         self.history_workspace_layout.setColumnStretch(0, 4)
         self.history_workspace_layout.setColumnStretch(1, 4)
         self.history_workspace_layout.setColumnStretch(2, 5)
-        self.history_workspace_layout.setRowStretch(row_offset, 1)
+        self.history_workspace_layout.setRowStretch(0, 1)
 
     def _get_selected_history_entry(self):
         if not hasattr(self, 'history_table'):
             return None
         selection = self.history_table.selectionModel()
         if not selection or not selection.selectedRows():
             return None
         row = selection.selectedRows()[0].row()
         history_items = getattr(self, '_history_results', [])
         return history_items[row] if 0 <= row < len(history_items) else None
 
     def _render_history_preview(self, entry):
         if not hasattr(self, 'history_patient_summary_label'):
             return
         if not entry:
             self.history_patient_summary_label.setText(
                 "<p style='color:#666;'>Seleccione una orden para ver los datos del paciente.</p>"
             )
             self._render_history_alerts([])
             self._render_history_detail([])
             return
         self._render_history_patient_summary(entry)
         self._render_history_alerts(self._extract_history_alert_tags(entry))
         self._render_history_detail(entry)
 
@@ -6668,280 +6652,249 @@ class MainWindow(QMainWindow):
         if re.search(r'\b(tb|tbc|tuberc)', combined):
             tags.append("TB previa")
         if re.search(r'\bcron', combined):
             tags.append("Dx crónico")
         if re.search(r'\b(dm|diabet)', combined):
             tags.append("DM")
         if "hta" in combined or "hipert" in combined:
             tags.append("HTA")
         if "anticoag" in combined:
             tags.append("Anticoagulación")
         has_critical = any(detail.get("is_critical") for detail in entry.get("test_details", []) or [])
         if "crit" in combined or has_critical:
             tags.append("Resultados críticos recientes")
         if "repetir" in combined:
             tags.append("Repetir muestra")
         pending_tests = entry.get("pending_tests") or []
         if pending_tests:
             tags.append("Exámenes pendientes hoy")
         deduped = []
         for tag in tags:
             if tag not in deduped:
                 deduped.append(tag)
         return deduped
 
     def _render_history_alerts(self, tags):
-        if not hasattr(self, 'history_alerts_grid'):
-            return
         prev_state = bool(getattr(self, 'history_has_alerts', False))
-        while self.history_alerts_grid.count():
-            item = self.history_alerts_grid.takeAt(0)
-            widget = item.widget()
-            if widget:
-                widget.deleteLater()
         if hasattr(self, 'history_alerts_bar_layout'):
             self._clear_layout(self.history_alerts_bar_layout)
         has_alerts = bool(tags)
-        self.history_alerts_placeholder.setVisible(False)
         if not has_alerts:
             self.history_has_alerts = False
-            if hasattr(self, 'history_alerts_panel'):
-                self.history_alerts_panel.setVisible(False)
             if hasattr(self, 'history_alerts_bar'):
                 self.history_alerts_bar.setVisible(False)
+            self._history_alert_tags = []
             if prev_state != has_alerts:
                 self._update_history_workspace_layout()
             return
         self.history_has_alerts = True
-        if hasattr(self, 'history_alerts_panel'):
-            self.history_alerts_panel.setVisible(True)
         if hasattr(self, 'history_alerts_bar'):
             self.history_alerts_bar.setVisible(True)
         color_map = {
             "Alergias": ("#ffe7cc", "#8a4b08"),
             "VIH reactivo previo": ("#ffd6d6", "#a12626"),
             "TB previa": ("#ffd6d6", "#a12626"),
             "Resultados críticos recientes": ("#ffd6d6", "#a12626"),
             "Anticoagulación": ("#fff1cc", "#7a4d00"),
             "HTA": ("#fff1cc", "#7a4d00"),
             "DM": ("#fff1cc", "#7a4d00"),
             "Embarazo": ("#e8e1ff", "#4b2e83"),
             "Repetir muestra": ("#ffe7cc", "#8a4b08"),
             "Dx crónico": ("#e7f3ff", "#1f4e79"),
             "Exámenes pendientes hoy": ("#ffe7cc", "#8a4b08"),
         }
+        self._history_alert_tags = tags
+        self._history_alert_color_map = color_map
+        self._layout_history_alerts_bar(tags, color_map)
+        if prev_state != has_alerts:
+            self._update_history_workspace_layout()
+
+    def _layout_history_alerts_bar(self, tags, color_map=None):
+        if not hasattr(self, 'history_alerts_bar_layout'):
+            return
+        self._clear_layout(self.history_alerts_bar_layout)
+        if not tags:
+            return
+        palette = color_map or {}
+        max_width = 0
+        if hasattr(self, 'history_alerts_bar_container'):
+            max_width = self.history_alerts_bar_container.width()
+        if max_width <= 0 and hasattr(self, 'history_alerts_bar'):
+            max_width = self.history_alerts_bar.width() - 40
+        if max_width <= 0:
+            max_width = 400
+        spacing = self.history_alerts_bar_layout.horizontalSpacing()
+        row = 0
+        col = 0
+        used_width = 0
+        max_rows = 2
+        line_heights = [0, 0]
+        overflow_count = 0
         for idx, tag in enumerate(tags):
-            bg, fg = color_map.get(tag, ("#e7f3ff", "#1f4e79"))
+            bg, fg = palette.get(tag, ("#e7f3ff", "#1f4e79"))
             chip = QLabel(tag)
             chip.setStyleSheet(
                 f"QLabel {{ background-color: {bg}; color: {fg}; border-radius: 8px; padding: 3px 8px; }}"
             )
             chip.setSizePolicy(QSizePolicy.Maximum, QSizePolicy.Fixed)
-            row = idx
-            col = 0
-            self.history_alerts_grid.addWidget(chip, row, col, Qt.AlignLeft)
-            if hasattr(self, 'history_alerts_bar_layout'):
-                bar_chip = QLabel(tag)
-                bar_chip.setStyleSheet(
-                    f"QLabel {{ background-color: {bg}; color: {fg}; border-radius: 8px; padding: 3px 8px; }}"
-                )
-                bar_chip.setSizePolicy(QSizePolicy.Maximum, QSizePolicy.Fixed)
-                self.history_alerts_bar_layout.addWidget(bar_chip)
-        if hasattr(self, 'history_alerts_bar_layout'):
-            self.history_alerts_bar_layout.addStretch()
-        if prev_state != has_alerts:
-            self._update_history_workspace_layout()
-
+            chip_size = chip.sizeHint()
+            chip_width = chip_size.width()
+            chip_height = chip_size.height()
+            if used_width and used_width + chip_width > max_width and row + 1 < max_rows:
+                row += 1
+                col = 0
+                used_width = 0
+            if used_width and used_width + chip_width > max_width and row + 1 >= max_rows:
+                overflow_count = len(tags) - idx
+                break
+            self.history_alerts_bar_layout.addWidget(chip, row, col, Qt.AlignLeft)
+            used_width += chip_width + spacing
+            line_heights[row] = max(line_heights[row], chip_height)
+            col += 1
+        if overflow_count:
+            overflow_label = QLabel(f"+{overflow_count}")
+            overflow_label.setStyleSheet(
+                "QLabel { background-color: #edf2f7; color: #1f2d3d; border-radius: 8px; padding: 3px 8px; }"
+            )
+            overflow_label.setSizePolicy(QSizePolicy.Maximum, QSizePolicy.Fixed)
+            self.history_alerts_bar_layout.addWidget(overflow_label, row, col, Qt.AlignLeft)
+            line_heights[row] = max(line_heights[row], overflow_label.sizeHint().height())
+        total_height = 0
+        for idx, height in enumerate(line_heights):
+            if height <= 0:
+                continue
+            if total_height > 0:
+                total_height += self.history_alerts_bar_layout.verticalSpacing()
+            total_height += height
+        if hasattr(self, 'history_alerts_bar_container') and total_height:
+            self.history_alerts_bar_container.setFixedHeight(total_height)
     def _render_history_detail(self, entry):
         if not hasattr(self, 'history_detail_tree'):
             return
         self.history_detail_tree.clear()
         self.history_detail_empty.setText("Sin exámenes registrados en esta orden.")
         detail_items = []
         if isinstance(entry, dict):
             detail_items = entry.get("test_details", [])
         if not detail_items:
             self.history_detail_tree.hide()
             self.history_detail_empty.show()
             return
         age_years = None
         age_value = entry.get("age") if isinstance(entry, dict) else None
         if age_value not in (None, "", "-"):
             try:
                 age_years = int(age_value)
             except (TypeError, ValueError):
                 age_years = None
         detail_context = {
             "patient": {"sex": entry.get("sex") if isinstance(entry, dict) else None, "birth_date": entry.get("birth_date") if isinstance(entry, dict) else None},
             "order": {"age_years": age_years}
         }
+        def build_parameter_rows(detail_item, context):
+            test_name = detail_item.get("test") or ""
+            raw_result = detail_item.get("raw_result")
+            structure = self._extract_result_structure(test_name, raw_result, context=context)
+            rows = []
+            if structure.get("type") == "structured":
+                for item in structure.get("items", []):
+                    if item.get("type") != "value":
+                        continue
+                    value = item.get("value")
+                    if self._is_blank_result(value):
+                        value = "Resultado no registrado"
+                    rows.append({
+                        "param": item.get("label", "") or "Resultado",
+                        "result": value,
+                        "param_id": item.get("key")
+                    })
+                if not rows:
+                    rows.append({"param": "Resultado", "result": "Resultado no registrado", "param_id": "resultado"})
+            else:
+                value = structure.get("value", "")
+                if self._is_blank_result(value):
+                    value = "Resultado no registrado"
+                rows.append({"param": "Resultado", "result": value, "param_id": "resultado"})
+            issue = detail_item.get("issue")
+            cancel_reason = detail_item.get("cancel_reason")
+            observation = detail_item.get("observation")
+            if issue:
+                rows.append({"param": "Notas", "result": issue, "param_id": "issue"})
+            if cancel_reason:
+                rows.append({"param": "Motivo de anulación", "result": cancel_reason, "param_id": "cancel_reason"})
+            if observation:
+                rows.append({"param": "Observaciones", "result": observation, "param_id": "observation"})
+            return rows
         sections = OrderedDict([
             ("results", "Realizado"),
             ("in_process", "En proceso"),
             ("pending", "Pendiente"),
             ("cancelled", "Anulado"),
         ])
         grouped = {key: [] for key in sections}
         order_emitted = bool(entry.get("emitted")) if isinstance(entry, dict) else False
         for item in detail_items:
             sample_status = (item.get("sample_status") or "").strip().lower()
             is_cancelled = bool(item.get("is_cancelled")) or sample_status == "anulado"
             is_rejected = sample_status == "rechazada"
             has_result = bool(item.get("has_result"))
             is_emitted = bool(item.get("is_emitted")) or order_emitted or sample_status in {"emitido", "validado"}
             if is_cancelled or is_rejected:
                 section_key = "cancelled"
             elif has_result or is_emitted:
                 section_key = "results"
             elif item.get("sample_received"):
                 section_key = "in_process"
             else:
                 section_key = "pending"
             grouped[section_key].append(item)
         any_rows = False
-        def resolve_template(parsed, test_name):
-            template_key = parsed.get("template") if isinstance(parsed, dict) else None
-            template = None
-            if template_key and template_key in TEST_TEMPLATES:
-                template = TEST_TEMPLATES.get(template_key)
-            elif template_key == "Hematocrito (automático)" and template_key not in TEST_TEMPLATES:
-                TEST_TEMPLATES[template_key] = build_hematocrit_template(include_auto_hemoglobin=True)
-                template = TEST_TEMPLATES.get(template_key)
-            if template is None:
-                template = TEST_TEMPLATES.get(test_name)
-            return template
-
-        def build_structured_values(parsed, template):
-            values = parsed.get("values", {})
-            current_section = ""
-            rows = []
-            for field_def in template.get("fields", []):
-                if field_def.get("type") == "section":
-                    current_section = field_def.get("label", "")
-                    continue
-                key = field_def.get("key")
-                if not key:
-                    continue
-                value = values.get(key, "")
-                if isinstance(value, str):
-                    stripped = value.strip()
-                    if stripped == "":
-                        continue
-                    display_value = " ".join(value.splitlines()).strip()
-                else:
-                    if self._is_blank_result(value):
-                        continue
-                    display_value = value
-                unit = field_def.get("unit")
-                field_type = field_def.get("type")
-                if unit and field_type not in ("bool", "text_area", "choice"):
-                    display_text = str(display_value)
-                    if not display_text.endswith(unit):
-                        display_value = f"{display_text} {unit}"
-                label = field_def.get("label", key)
-                if current_section:
-                    label = f"{current_section}: {label}"
-                rows.append({"param": label, "result": f"{display_value}"})
-            return rows
-
-        def build_result_display(detail_item, test_name):
-            raw_result = detail_item.get("raw_result")
-            observation = detail_item.get("observation")
-            issue = detail_item.get("issue")
-            summary_text = detail_item.get("summary_text")
-            summary_items = detail_item.get("summary_items") or []
-            if summary_text:
-                return str(summary_text)
-            if summary_items:
-                return "; ".join(str(item) for item in summary_items if item)
-            if self._is_blank_result(raw_result):
-                fallback_text = (observation or issue or "").strip()
-                return fallback_text if fallback_text else "Resultado no registrado"
-            parsed = self._parse_stored_result(raw_result)
-            if parsed.get("type") == "structured":
-                template = resolve_template(parsed, test_name)
-                if template:
-                    rows = build_structured_values(parsed, template)
-                    if rows:
-                        return " | ".join(f"{row['param']}: {row['result']}" for row in rows)
-                structured_text = self._structured_dict_to_text(parsed.get("values", {}))
-                if structured_text:
-                    return structured_text
-            text_value = parsed.get("value", raw_result or "")
-            if isinstance(text_value, str):
-                text_value = text_value.strip()
-            if text_value:
-                return str(text_value)
-            fallback_text = (observation or issue or "").strip()
-            return fallback_text if fallback_text else "Resultado no registrado"
-
-        def build_parameter_rows(detail_item, test_name):
-            raw_result = detail_item.get("raw_result")
-            observation = detail_item.get("observation")
-            issue = detail_item.get("issue")
-            cancel_reason = detail_item.get("cancel_reason")
-            parsed = self._parse_stored_result(raw_result)
-            template = resolve_template(parsed, test_name)
-            rows = []
-            if parsed.get("type") == "structured" and template:
-                rows = build_structured_values(parsed, template)
-            if not rows:
-                summary_text = build_result_display(detail_item, test_name)
-                if isinstance(summary_text, str) and summary_text.strip() == "":
-                    summary_text = "Resultado no registrado"
-                rows.append({"param": "Resultado", "result": summary_text})
-            if issue:
-                rows.append({"param": "Notas", "result": issue})
-            if cancel_reason:
-                rows.append({"param": "Motivo de anulación", "result": cancel_reason})
-            if observation:
-                rows.append({"param": "Observaciones", "result": observation})
-            return rows
-
         for section_key, section_label in sections.items():
             items = grouped.get(section_key, [])
             if not items:
                 continue
             any_rows = True
             section_item = QTreeWidgetItem([section_label, "", ""])
             section_item.setData(0, Qt.UserRole, "section")
             section_font = section_item.font(0)
             section_font.setBold(True)
             section_item.setFont(0, section_font)
             section_item.setFirstColumnSpanned(True)
             self.history_detail_tree.addTopLevelItem(section_item)
             for detail in items:
                 test_name = detail.get("test") or "—"
                 display_name = test_name
-                parameter_rows = build_parameter_rows(detail, test_name)
+                parameter_rows = build_parameter_rows(detail, detail_context)
                 test_item = QTreeWidgetItem([display_name, "", ""])
                 test_item.setData(0, Qt.UserRole, "exam")
+                test_item.setData(0, Qt.UserRole + 1, detail.get("test_id"))
                 test_item.setToolTip(0, test_name)
                 section_item.addChild(test_item)
                 for row in parameter_rows:
                     param_item = QTreeWidgetItem(["", row["param"], ""])
                     param_item.setData(0, Qt.UserRole, "param")
+                    param_item.setData(1, Qt.UserRole + 1, row.get("param_id"))
                     result_text = str(row["result"])
                     result_label = QLabel(result_text)
                     result_label.setWordWrap(True)
                     result_label.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)
                     result_label.setMinimumWidth(0)
                     result_label.setToolTip(result_text)
                     result_label.setTextFormat(Qt.PlainText)
                     result_label.setStyleSheet("padding: 2px 0;")
                     self.history_detail_tree.setItemWidget(param_item, 2, result_label)
                     test_item.addChild(param_item)
                 test_item.setExpanded(True)
             section_item.setExpanded(True)
         if any_rows:
             self.history_detail_tree.show()
             self.history_detail_empty.hide()
         else:
             self.history_detail_tree.hide()
             self.history_detail_empty.show()
 
     def _toggle_history_detail_item(self, item, column):
         if not item or item.data(0, Qt.UserRole) != "exam":
             return
         item.setExpanded(not item.isExpanded())
 
     def _update_history_detail_from_selection(self):
@@ -6988,50 +6941,51 @@ class MainWindow(QMainWindow):
         row = selection.selectedRows()[0].row()
         history_items = getattr(self, '_history_results', [])
         entry = history_items[row] if 0 <= row < len(history_items) else None
         self._render_history_preview(entry)
 
 
     def search_patient_history(self):
         if not hasattr(self, 'history_table'):
             return
         doc_number = self.history_doc_input.text().strip() if hasattr(self, 'history_doc_input') else ""
         last_name = self.history_lastname_input.text().strip() if hasattr(self, 'history_lastname_input') else ""
         if doc_number == "" and last_name == "":
             QMessageBox.warning(self, "Filtro requerido", "Ingrese un DNI o apellidos para realizar la búsqueda.")
             return
         if doc_number and not doc_number.isdigit():
             QMessageBox.warning(self, "Formato inválido", "El DNI debe contener solo números.")
             return
         self._clear_history_table()
         rows = self.labdb.get_patient_history(doc_number=doc_number or None, doc_type="DNI" if doc_number else None, last_name=last_name or None)
         records = []
         for row in rows:
             (
                 order_id,
                 date_str,
                 sample_date_str,
+                test_id,
                 test_name,
                 raw_result,
                 category,
                 first_name,
                 patient_last_name,
                 doc_type,
                 doc_value,
                 sex,
                 birth_date,
                 hcl,
                 origin,
                 height,
                 weight,
                 blood_pressure,
                 is_pregnant,
                 gest_age_weeks,
                 expected_delivery,
                 age_years,
                 order_obs,
                 requested_by,
                 insurance_type,
                 fua_number,
                 emitted,
                 emitted_at,
                 sample_status,
@@ -7061,50 +7015,51 @@ class MainWindow(QMainWindow):
             elif sample_received:
                 summary_items = [f"{test_name}: Recibida (pendiente resultado)"]
             result_text = "; ".join(summary_items)
             records.append({
                 "entry_id": entry_id,
                 "order_id": order_id,
                 "date": display_date,
                 "order_date_raw": date_str,
                 "sample_date_raw": sample_date_str,
                 "patient": patient_name,
                 "document": doc_text,
                 "doc_type": doc_type,
                 "doc_number": doc_value,
                 "birth_date": birth_date,
                 "hcl": hcl,
                 "height": height,
                 "weight": weight,
                 "blood_pressure": blood_pressure,
                 "sex": sex,
                 "origin": origin,
                 "is_pregnant": is_pregnant,
                 "gestational_age_weeks": gest_age_weeks,
                 "expected_delivery_date": expected_delivery,
                 "age": age_display,
                 "test": test_name,
+                "test_id": test_id,
                 "result": result_text,
                 "summary_items": summary_items,
                 "summary_text": summary_text,
                 "raw_result": raw_result,
                 "has_result": has_result,
                 "sample_received": sample_received,
                 "is_critical": self._detect_critical_result(raw_result, summary_items),
                 "category": category,
                 "order_observations": order_obs,
                 "requested_by": requested_by,
                 "insurance_type": insurance_type,
                 "fua_number": fua_number,
                 "emitted": emitted,
                 "emitted_at": emitted_at,
                 "first_name": first_name,
                 "last_name": patient_last_name,
                 "sample_status": sample_status,
                 "sample_issue": sample_issue,
                 "observation": observation,
                 "pending_since": pending_since,
                 "is_cancelled": bool(deleted),
                 "cancel_reason": deleted_reason
             })
         aggregated = self._aggregate_results_by_order(records)
         self._history_results = aggregated
 
EOF
)