diff --git a/main_window.py b/main_window.py
index 351f1e876860f7a391fd8afbf452b092fc6fd660..3dea5e1d1a2480c2397459a7902b1079aea75c8c 100644
--- a/main_window.py
+++ b/main_window.py
@@ -9,50 +9,51 @@ import unicodedata
 from collections import OrderedDict
 from PyQt5.QtWidgets import (QMainWindow, QWidget, QLabel, QPushButton, QVBoxLayout, QHBoxLayout,
                              QStackedWidget, QFormLayout, QScrollArea, QGroupBox, QComboBox,
                              QLineEdit, QTextEdit, QTableWidget, QTableWidgetItem, QFileDialog, QMessageBox, QCheckBox,
                              QDateEdit, QRadioButton, QButtonGroup, QDialog, QDialogButtonBox, QListWidget, QListWidgetItem,
                              QSpinBox, QInputDialog, QAbstractItemView, QGridLayout)
 from PyQt5.QtCore import QDate, QDateTime, Qt, QTimer
 from PyQt5.QtGui import QColor, QFont
 from fpdf import FPDF  # Asegúrese de tener fpdf instalado (pip install fpdf)
 
 LAB_TITLE = "Laboratorio P.S. Iñapari - 002789"
 
 MONTH_NAMES_ES = [
     "Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio",
     "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre"
 ]
 
 CATEGORY_DISPLAY_ORDER = [
     "HEMATOLOGÍA",
     "BIOQUÍMICA",
     "INMUNOLOGÍA",
     "PRUEBAS RÁPIDAS",
     "PARASITOLOGÍA",
     "MICROBIOLOGÍA",
     "MICROSCOPÍA",
+    "LABORATORIO REFERENCIAL",
     "OTROS",
     "TOMA DE MUESTRA"
 ]
 
 REGISTRY_ABBREVIATIONS = {
     "hematocrito": "Hto",
     "hematocrito (hto)": "Hto",
     "hemoglobina": "Hb",
     "hemoglobina (hb)": "Hb",
     "hemoglobina - hematocrito": "Hb/Hto",
     "hemoglobina hematocrito": "Hb/Hto",
     "leucocitos": "Leu",
     "leucocitos totales": "Leu",
     "recuento de leucocitos": "Leu",
     "recuento de hematies": "RBC",
     "recuento de hematies (rbc)": "RBC",
     "hematies": "RBC",
     "plaquetas": "Plaq",
     "recuento de plaquetas": "Plaq",
     "plaquetas totales": "Plaq",
     "vcm": "VCM",
     "hcm": "HCM",
     "chcm": "CHCM",
     "rdw": "RDW",
     "segmentados": "Seg",
@@ -880,74 +881,83 @@ SIMPLE_NUMERIC_TESTS = {
         "label": "PSA total",
         "unit": "ng/mL",
         "reference": "40-49 a: <2.5 | 50-59 a: <3.5 | 60-69 a: <4.5 | ≥70 a: <6.5 ng/mL",
         "placeholder": "Ej. 2.1"
     }
 }
 
 SIMPLE_TEXTAREA_TESTS = {
     "Lámina periférica": {
         "key": "descripcion",
         "label": "Descripción morfológica",
         "reference": "Eritrocitos normocíticos normocrómicos, leucocitos sin alteraciones, plaquetas adecuadas",
         "placeholder": "Describa morfología observada"
     },
     "Identificación bioquímica": {
         "key": "panel_bioquimico",
         "label": "Perfil bioquímico",
         "reference": "Describa pruebas realizadas según manual CLSI vigente",
         "placeholder": "Ej. Enterobacter cloacae, panel API 20E"
     },
     "Antibiograma": {
         "key": "antibiograma",
         "label": "Antibiograma",
         "reference": "Interpretar según guías CLSI/EUCAST",
         "placeholder": "Antibiótico - Interpretación (S/I/R)"
+    },
+    "BK (resultado referencial)": {
+        "key": "resultado",
+        "label": "Resultado BK",
+        "reference": "Describa gradación (Negativo, 1+, 2+, 3+) u observaciones del informe referencial",
+        "placeholder": "Ej. Negativo / BK 1+"
     }
 }
 
 BOOL_TESTS = {
     "Células LE": {"positive_text": "Positivo", "negative_text": "Negativo", "reference": "Negativo"},
     "Baciloscopía": {"positive_text": "BAAR positivo", "negative_text": "BAAR negativo", "reference": "No se observan bacilos ácido-alcohol resistentes"},
     "Gota gruesa": {"positive_text": "Hemoparásitos", "negative_text": "No se observan", "reference": "No se observan Plasmodium spp."},
     "Frotis para Leishmaniasis": {"positive_text": "Leishmania sp.", "negative_text": "No se observan", "reference": "No se observan amastigotes"},
     "Cultivo de Neisseria gonorrhoeae": {"positive_text": "Aislamiento positivo", "negative_text": "Sin aislamiento", "reference": "No se aisla N. gonorrhoeae"},
     "Cultivo de Campylobacter spp.": {"positive_text": "Aislamiento positivo", "negative_text": "Sin aislamiento", "reference": "No se aisla Campylobacter spp."},
     "Frotis para Bartonella": {"positive_text": "Cuerpos de Bartonella", "negative_text": "No se observan", "reference": "Negativo"},
     "Ácido sulfasalicílico al 3%": {"positive_text": "Positivo", "negative_text": "Negativo", "reference": "Negativo (proteínas ≤30 mg/dL)"},
     "Antígeno de superficie Hepatitis B (HBsAg)": {
         "positive_text": "Reactivo",
         "negative_text": "No reactivo",
         "reference": "No reactivo"
     },
     "Reagina plasmática rápida (RPR)": {
         "positive_text": "Reactivo",
         "negative_text": "No reactivo",
         "reference": "No reactivo"
     },
     "Proteína C reactiva (PCR) - Látex": {"positive_text": "Reactivo", "negative_text": "No reactivo", "reference": "No reactivo"},
-    "BHCG (Prueba de embarazo en sangre)": {"positive_text": "Positivo", "negative_text": "Negativo", "reference": "Negativo (<5 mUI/mL)"}
+    "BHCG (Prueba de embarazo en sangre)": {"positive_text": "Positivo", "negative_text": "Negativo", "reference": "Negativo (<5 mUI/mL)"},
+    "Serología Dengue (referencial)": {"positive_text": "Positivo", "negative_text": "Negativo", "reference": "Negativo"},
+    "Serología Leptospira (referencial)": {"positive_text": "Positivo", "negative_text": "Negativo", "reference": "Negativo"},
+    "Serología Leishmaniasis (referencial)": {"positive_text": "Positivo", "negative_text": "Negativo", "reference": "Negativo"}
 }
 
 SAMPLE_TEMPLATES = {
     "Leishmaniasis (toma de muestra)": build_sample_tracking_template("Registro de remisión según NTS para vigilancia de leishmaniasis"),
     "Dengue (toma de muestra)": build_sample_tracking_template("Mantener cadena de frío 2-8 °C"),
     "Leptospirosis (toma de muestra)": build_sample_tracking_template("Documentar envío a laboratorio de referencia"),
     "Covid-19 (hisopado nasofaríngeo)": build_sample_tracking_template("Remitir en medio viral a 4 °C"),
     "Carga viral de VIH / Recuento de CD4": build_sample_tracking_template("Registrar código de envío y hora"),
     "CLIA (PSA, Perfil tiroideo, etc.)": build_sample_tracking_template("Sin valores de referencia: registro de muestra derivada"),
     "Sangre venosa/arterial (examen de proceso)": build_sample_tracking_template("Control de cadena de custodia (sin valores analíticos)"),
     "Covid-19 (Prueba antigénica)": build_bool_observation_template("Positivo", "Negativo", "Negativo"),
     "Covid-19 (Prueba serológica)": build_bool_observation_template("Positivo", "Negativo", "Negativo"),
     "Dengue NS1/IgM/IgG (Prueba rápida)": build_bool_observation_template("Positivo", "Negativo", "Negativo"),
     "Hepatitis A (Prueba rápida)": build_bool_observation_template("Positivo", "Negativo", "Negativo"),
     "Hepatitis B (Prueba rápida)": build_bool_observation_template("Positivo", "Negativo", "Negativo"),
     "PSA (Prueba rápida)": build_bool_observation_template("Positivo", "Negativo", "Negativo"),
     "Sangre oculta en heces (Prueba rápida)": build_bool_observation_template("Positivo", "Negativo", "Negativo"),
     "Helicobacter pylori (Prueba rápida)": build_bool_observation_template("Positivo", "Negativo", "Negativo"),
     "VIH (Prueba rápida)": build_bool_observation_template("Reactivo", "No reactivo", "No reactivo"),
     "Sífilis (Prueba rápida)": build_bool_observation_template("Reactivo", "No reactivo", "No reactivo"),
     "VIH/Sífilis (Prueba combinada)": build_bool_observation_template("Reactivo", "No reactivo", "No reactivo"),
     "BHCG (Prueba de embarazo en sangre)": build_bool_observation_template("Positivo", "Negativo", "Negativo (<5 mUI/mL)")
 }
 
 for test_name, info in SIMPLE_NUMERIC_TESTS.items():
@@ -3388,109 +3398,119 @@ class MainWindow(QMainWindow):
         if not match:
             return None
         try:
             return float(match.group(0).replace(',', '.'))
         except ValueError:
             return None
 
     def _format_decimal(self, value, decimals=2):
         try:
             number = float(value)
         except (TypeError, ValueError):
             return str(value)
         formatted = f"{number:.{decimals}f}"
         if "." in formatted:
             formatted = formatted.rstrip('0').rstrip('.')
         return formatted
 
     def _map_category_group(self, category):
         normalized = (category or "").strip().upper()
         if normalized == "HEMATOLOGÍA":
             return "hematology"
         if normalized == "BIOQUÍMICA":
             return "biochemistry"
         if normalized in {"MICROBIOLOGÍA", "PARASITOLOGÍA", "MICROSCOPÍA"}:
             return "micro_parasito"
+        if normalized == "LABORATORIO REFERENCIAL":
+            return "others"
         return "others"
 
     def _aggregate_results_by_order(self, records):
         group_keys = ["hematology", "biochemistry", "micro_parasito", "others"]
         aggregated = []
         grouped = OrderedDict()
         for record in records:
             summary_items = record.get("summary_items")
             if not summary_items:
                 result_value = record.get("result", "")
                 if isinstance(result_value, str) and result_value.strip():
                     summary_items = [result_value.strip()]
                 elif not self._is_blank_result(result_value):
                     summary_items = [str(result_value)]
             if not summary_items:
                 continue
             order_id = record.get("order_id")
             if order_id is None:
                 continue
             entry = grouped.get(order_id)
             if not entry:
                 entry = {
                     "order_id": order_id,
                     "date": record.get("date", ""),
                     "order_date_raw": record.get("order_date_raw"),
                     "sample_date_raw": record.get("sample_date_raw"),
                     "patient": record.get("patient", ""),
                     "document": record.get("document", ""),
                     "doc_type": record.get("doc_type"),
                     "doc_number": record.get("doc_number"),
                     "birth_date": record.get("birth_date"),
                     "hcl": record.get("hcl"),
                     "sex": record.get("sex"),
                     "origin": record.get("origin"),
                     "is_pregnant": record.get("is_pregnant"),
                     "gestational_age_weeks": record.get("gestational_age_weeks"),
                     "expected_delivery_date": record.get("expected_delivery_date"),
                     "age": record.get("age", ""),
                     "first_name": record.get("first_name"),
                     "last_name": record.get("last_name"),
                     "observations": record.get("order_observations"),
                     "insurance_type": record.get("insurance_type"),
                     "fua_number": record.get("fua_number"),
                     "emitted": record.get("emitted"),
                     "emitted_at": record.get("emitted_at"),
                     "groups": {key: [] for key in group_keys},
-                    "tests": []
+                    "tests": [],
+                    "sample_statuses": []
                 }
                 grouped[order_id] = entry
             group_key = self._map_category_group(record.get("category"))
             for item in summary_items:
                 cleaned = str(item).strip()
                 if cleaned:
                     entry["groups"].setdefault(group_key, []).append(cleaned)
             test_name = record.get("test")
             if test_name:
                 test_clean = str(test_name).strip()
                 if test_clean and test_clean not in entry.setdefault("tests", []):
                     entry["tests"].append(test_clean)
+            status_info = {
+                "test": record.get("test"),
+                "status": record.get("sample_status"),
+                "issue": record.get("sample_issue"),
+                "pending_since": record.get("pending_since"),
+            }
+            entry.setdefault("sample_statuses", []).append(status_info)
         for entry in grouped.values():
             obs_text = entry.get("observations")
             if obs_text:
                 obs_clean = " ".join(str(obs_text).split())
                 if obs_clean and obs_clean.lower() not in {"n/a", "na", "-"}:
                     entry["groups"].setdefault("others", []).append(f"Obs: {obs_clean}")
             if any(entry["groups"].get(key) for key in group_keys):
                 aggregated.append(entry)
         return aggregated
 
     def _format_short_date(self, value):
         return self._format_date_display(value, "—")
 
     def _format_patient_block_for_registry(self, entry):
         def clean(text):
             if not text:
                 return ""
             return " ".join(str(text).split())
         def to_title(text):
             return text.title() if text else ""
         first = to_title(clean(entry.get("first_name")))
         last = to_title(clean(entry.get("last_name")))
         if last and first:
             name_line = f"{last}, {first}"
         elif last:
@@ -3595,50 +3615,107 @@ class MainWindow(QMainWindow):
     def _format_fua_display(self, entry):
         insurance = (entry.get("insurance_type") or "").strip().lower()
         fua_value = entry.get("fua_number")
         if insurance == "particular":
             return "No aplica"
         if isinstance(fua_value, str):
             fua_value = fua_value.strip()
         if fua_value:
             return str(fua_value)
         return "Pendiente"
 
     def _format_sample_status_text(self, status_value, note, pending_since=None):
         value = (status_value or "recibida").strip().lower()
         if value == "recibida":
             return ""
         label = "Pendiente" if value == "pendiente" else "Rechazada"
         date_suffix = ""
         if value == "pendiente" and pending_since:
             display = self._format_datetime_display(pending_since, "")
             if display:
                 date_suffix = f" (desde {display})"
         base = f"{label}{date_suffix}"
         if note:
             return f"{base} - {note}"
         return base
+
+    def _format_history_sample_status(self, entry):
+        statuses = entry.get("sample_statuses") or []
+        parts = []
+        for status_info in statuses:
+            text = self._format_sample_status_text(
+                status_info.get("status"),
+                status_info.get("issue"),
+                status_info.get("pending_since")
+            )
+            if not text:
+                text = "Recibida"
+            test_name = status_info.get("test")
+            if test_name:
+                parts.append(f"{test_name}: {text}")
+            else:
+                parts.append(text)
+        return "\n".join(parts) if parts else "-"
+
+    def _format_history_gestation(self, entry):
+        display = self._format_registry_pregnancy_line(entry)
+        return display if display else "-"
+
+    def _build_history_row_values(self, entry):
+        return [
+            self._format_date_for_registry(entry),
+            str(entry.get("order_id", "-")),
+            entry.get("patient", "-"),
+            entry.get("document", "-"),
+            self._format_birth_for_history(entry.get("birth_date")),
+            entry.get("age", "-"),
+            self._format_history_gestation(entry),
+            self._format_sex_display(entry.get("sex")),
+            entry.get("origin", "-") or "-",
+            entry.get("hcl", "-") or "-",
+            self._format_insurance_display(entry.get("insurance_type")),
+            self._format_fua_display(entry),
+            self._format_history_sample_status(entry),
+            "\n  ".join(entry.get("groups", {}).get("hematology", [])) or "-",
+            "\n  ".join(entry.get("groups", {}).get("biochemistry", [])) or "-",
+            "\n  ".join(entry.get("groups", {}).get("micro_parasito", [])) or "-",
+            "\n  ".join(entry.get("groups", {}).get("others", [])) or "-",
+            self._format_emission_status(entry.get("emitted"), entry.get("emitted_at"))
+        ]
+
+    def _populate_history_table_widget(self, table_widget, aggregated):
+        headers = getattr(self, 'history_headers', [])
+        if not headers or not isinstance(aggregated, list):
+            return
+        table_widget.setRowCount(len(aggregated))
+        for row_idx, entry in enumerate(aggregated):
+            values = self._build_history_row_values(entry)
+            for col_idx, value in enumerate(values):
+                item = QTableWidgetItem(str(value))
+                if headers[col_idx] in {"Orden", "Edad", "F. Nacimiento", "Sexo", "Tipo de seguro", "FUA", "Gestación"}:
+                    item.setTextAlignment(Qt.AlignCenter)
+                table_widget.setItem(row_idx, col_idx, item)
     def _calculate_age_years(self, patient_info, order_info):
         age_value = order_info.get('age_years') if isinstance(order_info, dict) else None
         if age_value is not None:
             try:
                 return int(age_value)
             except (TypeError, ValueError):
                 age_value = None
         if age_value is None:
             birth_date = patient_info.get('birth_date') if isinstance(patient_info, dict) else None
             if birth_date:
                 bd = QDate.fromString(birth_date, "yyyy-MM-dd")
                 if bd.isValid():
                     age_value = bd.daysTo(QDate.currentDate()) // 365
         return age_value
     def _format_age_text(self, patient_info, order_info):
         age_value = self._calculate_age_years(patient_info, order_info)
         return f"{age_value} años" if age_value is not None else "-"
 
     def _get_field_reference(self, field_def, context=None):
         if not field_def:
             return None
         reference = field_def.get("reference")
         if not reference:
             return reference
         effective_context = context or self.current_order_context
@@ -4696,116 +4773,128 @@ class MainWindow(QMainWindow):
         controls_layout.addWidget(self.view_activity_btn)
         controls_layout.addWidget(self.export_activity_pdf_btn)
         controls_layout.addWidget(self.export_activity_csv_btn)
         controls_layout.addWidget(self.export_activity_delivery_btn)
         controls_layout.addWidget(self.delete_activity_btn)
         controls_layout.addStretch()
         layout.addLayout(controls_layout)
         self.activity_caption = QLabel()
         self.activity_caption.setStyleSheet("font-weight: bold;")
         layout.addWidget(self.activity_caption)
         self.activity_table = QTableWidget(0, 8)
         self.activity_table.setHorizontalHeaderLabels([
             "F. muestra / Registro",
             "Orden",
             "Paciente",
             "Documento",
             "Edad",
             "Prueba",
             "Estado",
             "Resultado"
         ])
         self.activity_table.setAlternatingRowColors(True)
         self.activity_table.horizontalHeader().setStretchLastSection(True)
         self.activity_table.setSelectionMode(QTableWidget.MultiSelection)
         layout.addWidget(self.activity_table)
-        history_group = QGroupBox("Historial por DNI")
+        history_group = QGroupBox("Historial de pacientes")
         history_layout = QVBoxLayout(history_group)
         history_search_layout = QHBoxLayout()
         history_search_layout.addWidget(QLabel("DNI:"))
         self.history_doc_input = QLineEdit()
         self.history_doc_input.setPlaceholderText("Ingrese DNI")
         history_search_layout.addWidget(self.history_doc_input)
+        history_search_layout.addWidget(QLabel("Apellidos:"))
+        self.history_lastname_input = QLineEdit()
+        self.history_lastname_input.setPlaceholderText("Ej. PEREZ / PEREZ GARCIA")
+        history_search_layout.addWidget(self.history_lastname_input)
         self.history_search_btn = QPushButton("Buscar")
         history_search_layout.addWidget(self.history_search_btn)
         self.history_open_btn = QPushButton("Ver en emisión")
         self.history_open_btn.setEnabled(False)
         history_search_layout.addWidget(self.history_open_btn)
         self.history_fua_btn = QPushButton("Registrar FUA")
         self.history_fua_btn.setEnabled(False)
         history_search_layout.addWidget(self.history_fua_btn)
+        self.history_window_btn = QPushButton("Ventana de historial")
+        self.history_window_btn.setEnabled(False)
+        history_search_layout.addWidget(self.history_window_btn)
         history_search_layout.addStretch()
         history_layout.addLayout(history_search_layout)
         history_headers = [
             "F. muestra / Registro",
             "Orden",
             "Paciente",
             "Documento",
             "F. Nacimiento",
             "Edad",
+            "Gestación",
             "Sexo",
             "Procedencia",
             "HCL",
             "Tipo de seguro",
             "FUA",
+            "Seguimiento",
             "Hematología",
             "Bioquímica",
             "Micro/Parasitología",
             "Otros exámenes",
             "Emitido"
         ]
         self.history_table = QTableWidget(0, len(history_headers))
         self.history_table.setHorizontalHeaderLabels(history_headers)
         self.history_table.setSelectionBehavior(QTableWidget.SelectRows)
         self.history_table.setSelectionMode(QTableWidget.SingleSelection)
         self.history_table.setAlternatingRowColors(True)
         self.history_table.setWordWrap(True)
         self.history_table.verticalHeader().setVisible(False)
         self.history_table.horizontalHeader().setStretchLastSection(True)
+        self.history_headers = history_headers
         self.history_column_map = {header: idx for idx, header in enumerate(history_headers)}
         history_layout.addWidget(self.history_table)
         layout.addWidget(history_group)
         self._stats_controls_ready = False
         self.stats_mode_combo.currentIndexChanged.connect(self._update_stats_period_controls)
         self.stats_month_combo.currentIndexChanged.connect(lambda _: self.refresh_statistics())
         self.stats_quarter_combo.currentIndexChanged.connect(lambda _: self.refresh_statistics())
         self.stats_year_spin.valueChanged.connect(lambda _: self.refresh_statistics())
         self._history_results = []
         self.range_combo.currentIndexChanged.connect(self._update_range_controls)
         self.view_activity_btn.clicked.connect(self.load_activity_summary)
         self.export_activity_pdf_btn.clicked.connect(lambda: self.export_activity_record("pdf"))
         self.export_activity_csv_btn.clicked.connect(lambda: self.export_activity_record("csv"))
         self.export_activity_delivery_btn.clicked.connect(self.export_activity_delivery_sheet)
         self.delete_activity_btn.clicked.connect(self.delete_selected_activity_entries)
         self._update_range_controls()
         self._stats_controls_ready = True
         self._update_stats_period_controls()
         self.history_doc_input.returnPressed.connect(self.search_patient_history)
+        self.history_lastname_input.returnPressed.connect(self.search_patient_history)
         self.history_search_btn.clicked.connect(self.search_patient_history)
         self.history_open_btn.clicked.connect(self.open_history_order_from_analysis)
         self.history_table.itemSelectionChanged.connect(self._on_history_selection_changed)
         self.history_fua_btn.clicked.connect(self.edit_history_fua)
+        self.history_window_btn.clicked.connect(self.open_history_window)
     def refresh_statistics(self):
         if not getattr(self, '_stats_controls_ready', False):
             return
         period = self._get_statistics_period()
         start_dt = datetime.datetime.combine(period['start'], datetime.time(0, 0, 0))
         end_dt = datetime.datetime.combine(period['end'], datetime.time(23, 59, 59))
         stats = self.labdb.get_statistics(start_dt.isoformat(sep=' '), end_dt.isoformat(sep=' '))
         summary_lines = [
             f"Período: {period['label']}",
             f"Pacientes atendidos: {stats['total_patients']}",
             f"Órdenes realizadas: {stats['total_orders']}",
             f"Pruebas realizadas: {stats['total_tests_conducted']}"
         ]
         self.stats_label.setText("\n".join(summary_lines))
         self.stats_table.setRowCount(0)
         detail = stats.get('by_category_detail', OrderedDict())
         ordered_categories = [cat for cat in CATEGORY_DISPLAY_ORDER if cat in detail]
         remaining = [cat for cat in detail.keys() if cat not in ordered_categories]
         categories = ordered_categories + remaining
         header_font = QFont()
         header_font.setBold(True)
         highlight_color = QColor(230, 242, 235)
         for category in categories:
             data = detail.get(category, {})
             total = data.get('total', 0)
@@ -5457,209 +5546,212 @@ class MainWindow(QMainWindow):
                         text_y += line_height
                     start_x += width
                 pdf.set_xy(pdf.l_margin, start_y + header_height)
                 pdf.set_font("Arial", '', 7.2)
             row_start_x = pdf.l_margin
             row_start_y = pdf.get_y()
             for idx, column in enumerate(columns):
                 width = column_widths[idx]
                 pdf.rect(row_start_x, row_start_y, width, row_height)
                 text_y = row_start_y + padding_y
                 for line in wrapped[idx]:
                     pdf.set_xy(row_start_x + padding_x, text_y)
                     pdf.cell(width - 2 * padding_x, line_height, line, border=0)
                     text_y += line_height
                 row_start_x += width
             pdf.set_xy(pdf.l_margin, row_start_y + row_height)
         pdf.set_margins(prev_left, prev_top, prev_right)
         pdf.set_auto_page_break(prev_auto, margin=prev_bottom)
 
     def _clear_history_table(self):
         if hasattr(self, 'history_table'):
             self.history_table.setRowCount(0)
         self._history_results = []
         if hasattr(self, 'history_open_btn'):
             self.history_open_btn.setEnabled(False)
+        if hasattr(self, 'history_window_btn'):
+            self.history_window_btn.setEnabled(False)
 
     def _on_history_selection_changed(self):
         if not hasattr(self, 'history_table'):
             return
         selection = self.history_table.selectionModel()
         has_selection = bool(selection.selectedRows()) if selection else False
         if hasattr(self, 'history_open_btn'):
             self.history_open_btn.setEnabled(has_selection)
         if hasattr(self, 'history_fua_btn'):
             enable_fua = False
             tooltip = ""
             if has_selection and selection:
                 indexes = selection.selectedRows()
                 if indexes:
                     row = indexes[0].row()
                     history_items = getattr(self, '_history_results', [])
                     if 0 <= row < len(history_items):
                         entry = history_items[row]
                         insurance = (entry.get("insurance_type") or "").strip().lower()
                         if insurance == "particular":
                             tooltip = "Las atenciones particulares no requieren FUA."
                         else:
                             enable_fua = True
             self.history_fua_btn.setEnabled(enable_fua)
             self.history_fua_btn.setToolTip(tooltip)
 
 
     def search_patient_history(self):
         if not hasattr(self, 'history_table'):
             return
         doc_number = self.history_doc_input.text().strip() if hasattr(self, 'history_doc_input') else ""
-        if doc_number == "":
-            QMessageBox.warning(self, "DNI requerido", "Ingrese un DNI para realizar la búsqueda.")
+        last_name = self.history_lastname_input.text().strip() if hasattr(self, 'history_lastname_input') else ""
+        if doc_number == "" and last_name == "":
+            QMessageBox.warning(self, "Filtro requerido", "Ingrese un DNI o apellidos para realizar la búsqueda.")
             return
-        if not doc_number.isdigit():
+        if doc_number and not doc_number.isdigit():
             QMessageBox.warning(self, "Formato inválido", "El DNI debe contener solo números.")
             return
         self._clear_history_table()
-        rows = self.labdb.get_patient_history_by_document(doc_number, "DNI")
+        rows = self.labdb.get_patient_history(doc_number=doc_number or None, doc_type="DNI" if doc_number else None, last_name=last_name or None)
         records = []
         for row in rows:
             (
                 order_id,
                 date_str,
                 sample_date_str,
                 test_name,
                 raw_result,
                 category,
                 first_name,
-                last_name,
+                patient_last_name,
                 doc_type,
                 doc_value,
                 sex,
                 birth_date,
                 hcl,
                 origin,
+                is_pregnant,
+                gest_age_weeks,
+                expected_delivery,
                 age_years,
                 order_obs,
                 insurance_type,
                 fua_number,
                 emitted,
                 emitted_at,
                 sample_status,
                 sample_issue,
                 observation,
+                pending_since,
                 entry_id
             ) = row
             display_date = self._format_date_display(sample_date_str, "-")
             if display_date == "-":
                 display_date = self._format_datetime_display(date_str, date_str or "-")
-            patient_name = " ".join(part for part in [(first_name or "").upper(), (last_name or "").upper()] if part).strip() or "-"
+            patient_name = " ".join(part for part in [(first_name or "").upper(), (patient_last_name or "").upper()] if part).strip() or "-"
             doc_text = " ".join(part for part in (doc_type, doc_value) if part).strip() or "-"
             age_display = str(age_years) if age_years not in (None, "") else "-"
             context = {
                 "patient": {"sex": sex, "birth_date": birth_date},
                 "order": {"age_years": age_years}
             }
             summary_items = self._build_registry_summary(test_name, raw_result, context=context)
             if not summary_items:
                 continue
             result_text = "; ".join(summary_items)
             records.append({
                 "entry_id": entry_id,
                 "order_id": order_id,
                 "date": display_date,
                 "order_date_raw": date_str,
                 "sample_date_raw": sample_date_str,
                 "patient": patient_name,
                 "document": doc_text,
                 "doc_type": doc_type,
                 "doc_number": doc_value,
                 "birth_date": birth_date,
                 "hcl": hcl,
                 "sex": sex,
                 "origin": origin,
+                "is_pregnant": is_pregnant,
+                "gestational_age_weeks": gest_age_weeks,
+                "expected_delivery_date": expected_delivery,
                 "age": age_display,
                 "test": test_name,
                 "result": result_text,
                 "summary_items": summary_items,
                 "category": category,
                 "order_observations": order_obs,
                 "insurance_type": insurance_type,
                 "fua_number": fua_number,
                 "emitted": emitted,
                 "emitted_at": emitted_at,
                 "first_name": first_name,
-                "last_name": last_name,
+                "last_name": patient_last_name,
                 "sample_status": sample_status,
                 "sample_issue": sample_issue,
-                "observation": observation
+                "observation": observation,
+                "pending_since": pending_since
             })
         aggregated = self._aggregate_results_by_order(records)
         self._history_results = aggregated
-        self.history_table.setRowCount(len(aggregated))
-        headers = [
-            "date",
-            "order_id",
-            "patient",
-            "document",
-            "birth",
-            "age",
-            "sex",
-            "origin",
-            "hcl",
-            "insurance",
-            "fua",
-            "hematology",
-            "biochemistry",
-            "micro_parasito",
-            "others",
-            "emitted"
-        ]
-        for row_idx, entry in enumerate(aggregated):
-            values = [
-                self._format_date_for_registry(entry),
-                str(entry.get("order_id", "-")),
-                entry.get("patient", "-"),
-                entry.get("document", "-"),
-                self._format_birth_for_history(entry.get("birth_date")),
-                entry.get("age", "-"),
-                self._format_sex_display(entry.get("sex")),
-                entry.get("origin", "-") or "-",
-                entry.get("hcl", "-") or "-",
-                self._format_insurance_display(entry.get("insurance_type")),
-                self._format_fua_display(entry),
-                "\n  ".join(entry.get("groups", {}).get("hematology", [])) or "-",
-                "\n  ".join(entry.get("groups", {}).get("biochemistry", [])) or "-",
-                "\n  ".join(entry.get("groups", {}).get("micro_parasito", [])) or "-",
-                "\n  ".join(entry.get("groups", {}).get("others", [])) or "-",
-                self._format_emission_status(entry.get("emitted"), entry.get("emitted_at"))
-            ]
-            for col_idx, value in enumerate(values):
-                item = QTableWidgetItem(str(value))
-                if headers[col_idx] in {"order_id", "age", "birth", "sex", "insurance", "fua"}:
-                    item.setTextAlignment(Qt.AlignCenter)
-                self.history_table.setItem(row_idx, col_idx, item)
+        self._populate_history_table_widget(self.history_table, aggregated)
         if not aggregated:
-            QMessageBox.information(self, "Sin resultados", "No se encontró historial con resultados registrados para este DNI.")
+            QMessageBox.information(self, "Sin resultados", "No se encontró historial con resultados registrados para los filtros ingresados.")
         self._on_history_selection_changed()
+        if hasattr(self, 'history_window_btn'):
+            self.history_window_btn.setEnabled(bool(aggregated))
+
+    def open_history_window(self):
+        aggregated = getattr(self, '_history_results', [])
+        if not aggregated:
+            QMessageBox.information(self, "Sin resultados", "Primero realice una búsqueda en el historial.")
+            return
+        dialog = QDialog(self)
+        dialog.setWindowTitle("Historial detallado de pacientes")
+        layout = QVBoxLayout(dialog)
+        filters = []
+        if hasattr(self, 'history_doc_input'):
+            doc_value = self.history_doc_input.text().strip()
+            if doc_value:
+                filters.append(f"DNI: {doc_value}")
+        if hasattr(self, 'history_lastname_input'):
+            last_value = self.history_lastname_input.text().strip()
+            if last_value:
+                filters.append(f"Apellidos: {last_value}")
+        filter_text = ", ".join(filters) if filters else "Sin filtros adicionales"
+        layout.addWidget(QLabel(f"Filtros aplicados: {filter_text}"))
+        table = QTableWidget(0, len(getattr(self, 'history_headers', [])))
+        table.setHorizontalHeaderLabels(getattr(self, 'history_headers', []))
+        table.setAlternatingRowColors(True)
+        table.horizontalHeader().setStretchLastSection(True)
+        table.setWordWrap(True)
+        table.verticalHeader().setVisible(False)
+        table.setSelectionBehavior(QTableWidget.SelectRows)
+        table.setSelectionMode(QTableWidget.SingleSelection)
+        self._populate_history_table_widget(table, aggregated)
+        layout.addWidget(table)
+        dialog.resize(1150, 650)
+        dialog.exec_()
 
     def open_history_order_from_analysis(self):
         if not hasattr(self, 'history_table'):
             return
         selection = self.history_table.selectionModel()
         if not selection:
             return
         indexes = selection.selectedRows()
         if not indexes:
             QMessageBox.information(self, "Sin selección", "Seleccione una orden para abrirla en la emisión.")
             return
         row = indexes[0].row()
         history_items = getattr(self, '_history_results', [])
         if row >= len(history_items):
             return
         order_id = history_items[row].get("order_id")
         if not order_id:
             QMessageBox.warning(self, "Orden no disponible", "No se pudo determinar el número de orden seleccionado.")
             return
         if hasattr(self, 'include_emitted_checkbox'):
             self.include_emitted_checkbox.setChecked(True)
         self.populate_completed_orders()
         self._select_order_in_combo(self.combo_completed, order_id)
         self.display_selected_result()
         self.stack.setCurrentWidget(self.page_emitir)
