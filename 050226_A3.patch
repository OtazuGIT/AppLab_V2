 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/main_window.py b/main_window.py
index df6c07b593de5c44ab1fc275b170a9232f0a9bc0..9c0ff0323982cef0ad1baec381fdd5020364c6df 100644
--- a/main_window.py
+++ b/main_window.py
@@ -1,48 +1,57 @@
 # main_window.py
 import copy
 import datetime
 import html
 import inspect
 import json
 import os
 import re
 import unicodedata
 from collections import OrderedDict
 from PyQt5.QtWidgets import (QMainWindow, QWidget, QLabel, QPushButton, QVBoxLayout, QHBoxLayout,
                              QStackedWidget, QTabWidget, QFormLayout, QScrollArea, QGroupBox, QComboBox,
                              QLineEdit, QTextEdit, QTableWidget, QTableWidgetItem, QFileDialog, QMessageBox, QCheckBox,
                              QDateEdit, QRadioButton, QButtonGroup, QDialog, QDialogButtonBox, QListWidget, QListWidgetItem,
                              QSpinBox, QInputDialog, QAbstractItemView, QGridLayout, QToolButton, QFrame, QSizePolicy,
                              QTreeWidget, QTreeWidgetItem, QStyle, QToolBox, QHeaderView)
 from PyQt5.QtCore import QDate, QDateTime, Qt, QTimer
 from PyQt5.QtGui import QColor, QFont, QBrush
 from fpdf import FPDF  # Asegúrese de tener fpdf instalado (pip install fpdf)
 from openpyxl import Workbook
 
 LAB_TITLE = "Laboratorio P.S. Iñapari - 002789"
 
+SAMPLE_TYPE_DEFAULTS = {
+    "examen completo de orina": "Orina de chorro medio",
+    "examen general de orina": "Orina de chorro medio",
+    "sedimento urinario": "Orina de chorro medio",
+    "urocultivo": "Orina de chorro medio",
+    "secrecion vaginal": "Secreción vaginal",
+    "secrecion (otros sitios)": "Secreción"
+}
+
 MONTH_NAMES_ES = [
     "Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio",
     "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre"
 ]
 
 CATEGORY_DISPLAY_ORDER = [
     "HEMATOLOGÍA",
     "BIOQUÍMICA",
     "INMUNOLOGÍA",
     "PRUEBAS RÁPIDAS",
     "PARASITOLOGÍA",
     "MICROBIOLOGÍA",
     "MICROSCOPÍA",
     "LABORATORIO REFERENCIAL",
     "OTROS",
     "TOMA DE MUESTRA"
 ]
 
 REGISTRY_ABBREVIATIONS = {
     "hematocrito": "Hto",
     "hematocrito (hto)": "Hto",
     "hemoglobina": "Hb",
     "hemoglobina (hb)": "Hb",
     "hemoglobina - hematocrito": "Hb/Hto",
     "hemoglobina hematocrito": "Hb/Hto",
@@ -2737,50 +2746,51 @@ class MainWindow(QMainWindow):
         sample_display = self._format_date_display(order_info.get('sample_date'), "-")
         requester_display = order_info.get('requested_by') or "-"
         origin_display = (patient_info.get('origin') or '-').upper()
         insurance_display = self._format_insurance_display(order_info.get('insurance_type'))
         _add_summary(0, 0, "Paciente", patient_name)
         _add_summary(0, 2, "Documento", doc_display)
         _add_summary(1, 0, "F. registro", order_timestamp)
         _add_summary(1, 2, "F. muestra", sample_display)
         _add_summary(2, 0, "Solicitante", requester_display)
         _add_summary(2, 2, "Procedencia", origin_display)
         _add_summary(3, 0, "Seguro", insurance_display)
         fua_display = order_info.get('fua_number') or "-"
         _add_summary(3, 2, "FUA", fua_display if insurance_display != "PARTICULAR" else "No aplica")
         self.results_layout.addWidget(summary_group)
         if hasattr(self, 'results_add_tests_btn'):
             self.results_add_tests_btn.setEnabled(True)
         order_test_names = [name for (name, *_rest) in rows]
         for entry in rows:
             (
                 test_name,
                 raw_result,
                 category,
                 sample_status,
                 sample_issue,
                 observation,
+                sample_type,
                 _entry_id,
                 pending_since
             ) = entry
             template = None
             template_name = test_name
             if test_name == "Hematocrito":
                 auto_mode = self._should_auto_calculate_hb(order_test_names)
                 template = build_hematocrit_template(auto_mode)
                 if auto_mode:
                     template_name = "Hematocrito (automático)"
                     TEST_TEMPLATES[template_name] = copy.deepcopy(template)
             else:
                 base_template = TEST_TEMPLATES.get(test_name)
                 if base_template is not None:
                     template = copy.deepcopy(base_template)
                 elif category == "PRUEBAS RÁPIDAS":
                     template = build_bool_observation_template()
                     TEST_TEMPLATES[test_name] = copy.deepcopy(template)
             group_box = QGroupBox(test_name)
             group_box.setStyleSheet("QGroupBox { font-weight: bold; }")
             container_layout = QVBoxLayout()
             header_layout = QHBoxLayout()
             header_layout.addStretch()
             status_container = QWidget()
             status_layout = QHBoxLayout(status_container)
@@ -2791,50 +2801,56 @@ class MainWindow(QMainWindow):
             status_combo.addItem("Recibida", "recibida")
             status_combo.addItem("Pendiente", "pendiente")
             status_combo.addItem("Rechazada", "rechazada")
             status_value = (sample_status or "recibida").strip().lower()
             idx = status_combo.findData(status_value)
             if idx >= 0:
                 status_combo.setCurrentIndex(idx)
             issue_input = QLineEdit()
             issue_input.setPlaceholderText("Detalle / motivo (si aplica)")
             if sample_issue:
                 issue_input.setText(str(sample_issue))
             btn_pending = QPushButton("Marcar pendiente")
             btn_pending.setStyleSheet("QPushButton { font-size: 10px; }")
             status_layout.addWidget(status_label)
             status_layout.addWidget(status_combo)
             status_layout.addWidget(issue_input, 1)
             status_layout.addWidget(btn_pending)
             pending_since_label = QLabel()
             pending_since_label.setStyleSheet("color: #8e44ad; font-size: 11px;")
             status_layout.addWidget(pending_since_label)
             observation_edit = QTextEdit()
             observation_edit.setFixedHeight(40)
             observation_edit.setPlaceholderText("Observaciones de la muestra (opcional)")
             if observation:
                 observation_edit.setPlainText(str(observation))
+            sample_type_input = QLineEdit()
+            sample_type_input.setPlaceholderText("Tipo de muestra")
+            resolved_sample_type = (sample_type or "").strip() if isinstance(sample_type, str) else ""
+            if not resolved_sample_type:
+                resolved_sample_type = self._default_sample_type_for_test(test_name)
+            sample_type_input.setText(resolved_sample_type)
             remove_button = QPushButton("Quitar examen")
             remove_button.setStyleSheet("QPushButton { font-size: 10px; color: #c0392b; }")
             remove_button.clicked.connect(lambda _=False, name=test_name: self._prompt_remove_test(name))
             header_layout.addWidget(remove_button)
             container_layout.addLayout(header_layout)
             container_layout.addWidget(status_container)
             group_layout = QFormLayout()
             group_layout.setLabelAlignment(Qt.AlignLeft)
             container_layout.addLayout(group_layout)
             group_box.setLayout(container_layout)
             parsed = self._parse_stored_result(raw_result)
             existing_values = {}
             if parsed.get("type") == "structured":
                 existing_values = parsed.get("values", {})
             field_entries = {}
             if template:
                 for field_def in template.get("fields", []):
                     if field_def.get("type") == "section":
                         section_label = QLabel(field_def.get("label", ""))
                         section_label.setStyleSheet("font-weight: bold; color: #2c3e50; padding-top:4px;")
                         group_layout.addRow(section_label)
                         continue
                     label_text, field_widget, widget_info = self._create_structured_field(field_def, existing_values, self.current_order_context)
                     widget_info["definition"] = field_def
                     key = field_def.get("key")
@@ -2844,55 +2860,57 @@ class MainWindow(QMainWindow):
                 self._apply_auto_calculations(field_entries, template)
                 self.order_fields[test_name] = {
                     "template": template,
                     "template_name": template_name,
                     "fields": field_entries
                 }
             else:
                 default_value = ""
                 if parsed.get("type") == "text":
                     default_value = parsed.get("value", "")
                 elif parsed.get("type") == "structured":
                     default_value = self._structured_dict_to_text(parsed.get("values", {}))
                 edit = QLineEdit()
                 edit.setText(default_value)
                 group_layout.addRow("Resultado:", edit)
                 self.order_fields[test_name] = {
                     "template": None,
                     "fields": {
                         "__value__": {
                             "type": "line",
                             "widget": edit,
                             "definition": {"key": "__value__", "label": "Resultado"}
                         }
                     }
                 }
+            group_layout.addRow("Tipo de muestra:", sample_type_input)
             group_layout.addRow("Obs. de la muestra:", observation_edit)
             meta_info = {
                 "status_widget": status_combo,
                 "issue_widget": issue_input,
                 "observation_widget": observation_edit,
+                "sample_type_widget": sample_type_input,
                 "initial_status": status_value,
                 "pending_since": pending_since,
                 "pending_label": pending_since_label,
             }
 
             def _refresh_pending_label():
                 current_index = status_combo.currentIndex()
                 current_value = status_combo.itemData(current_index)
                 if current_value == "pendiente":
                     timestamp = meta_info.get("pending_since")
                     if timestamp:
                         display = self._format_datetime_display(timestamp, "-", include_seconds=False)
                         pending_since_label.setText(f"Pendiente desde: {display}")
                     else:
                         pending_since_label.setText("Pendiente desde: se registrará al guardar")
                     pending_since_label.setVisible(True)
                 else:
                     pending_since_label.clear()
                     pending_since_label.setVisible(False)
 
             def _update_issue_state(index):
                 value = status_combo.itemData(index)
                 needs_detail = value in {"pendiente", "rechazada"}
                 issue_input.setEnabled(needs_detail)
                 if value == "pendiente":
@@ -2934,93 +2952,98 @@ class MainWindow(QMainWindow):
         if reply == QMessageBox.No:
             return
         removed = self.labdb.remove_test_from_order(self.selected_order_id, test_name)
         if removed:
             QMessageBox.information(self, "Prueba eliminada", f"Se quitó '{test_name}' de la orden.")
             self.populate_pending_orders()
             self.populate_completed_orders()
             self.load_order_fields()
         else:
             QMessageBox.warning(self, "Acción no realizada", "No se pudo quitar la prueba seleccionada.")
 
     def save_results(self):
         # Guardar los resultados ingresados para la orden seleccionada
         if not self.selected_order_id:
             return
         results_payload = {}
         has_empty = False
         pending_samples = 0
         pending_tests = []
         for test_name, info in self.order_fields.items():
             template = info.get("template")
             meta = info.get("meta", {})
             status_combo = meta.get("status_widget")
             issue_widget = meta.get("issue_widget")
             observation_widget = meta.get("observation_widget")
+            sample_type_widget = meta.get("sample_type_widget")
             pending_since_value = meta.get("pending_since")
             status_value = "recibida"
             if status_combo:
                 status_data = status_combo.currentData()
                 if status_data:
                     status_value = str(status_data).strip().lower()
                 else:
                     status_value = status_combo.currentText().strip().lower() or "recibida"
             issue_value = issue_widget.text().strip() if issue_widget else ""
             observation_value = observation_widget.toPlainText().strip() if observation_widget else ""
+            sample_type_value = sample_type_widget.text().strip() if sample_type_widget else ""
+            if not sample_type_value:
+                sample_type_value = self._default_sample_type_for_test(test_name)
             if status_value == "pendiente":
                 pending_samples += 1
                 pending_tests.append({
                     "name": test_name,
                     "issue": issue_value,
                 })
             else:
                 pending_since_value = None
             if status_value == "recibida":
                 issue_value = ""
             if template:
                 values = {}
                 for key, field_info in info["fields"].items():
                     value = self._get_widget_value(field_info)
                     values[key] = value
                     if status_value == "recibida" and value == "" and not field_info["definition"].get("optional", False):
                         has_empty = True
                 result_value = {
                     "type": "structured",
                     "template": info.get("template_name", test_name),
                     "values": values
                 }
             else:
                 field_info = info["fields"].get("__value__")
                 value = self._get_widget_value(field_info)
                 if status_value == "recibida" and value == "":
                     has_empty = True
                 result_value = value
             results_payload[test_name] = {
                 "result": result_value,
                 "sample_status": status_value,
                 "sample_issue": issue_value,
                 "observation": observation_value,
+                "sample_type": sample_type_value,
                 "pending_since": pending_since_value
             }
         if has_empty:
             reply = QMessageBox.question(
                 self,
                 "Confirmar",
                 "Hay pruebas o campos sin resultado. ¿Guardar de todos modos?",
                 QMessageBox.Yes | QMessageBox.No
             )
             if reply == QMessageBox.No:
                 return
         completed = self.labdb.save_results(self.selected_order_id, results_payload)
         followup_order_id = None
         updated_completion = None
         if pending_tests:
             followup_order_id, updated_completion = self.labdb.ensure_followup_order_for_pending(
                 self.selected_order_id,
                 pending_tests,
                 self.user.get('id')
             )
             if updated_completion is not None:
                 completed = updated_completion
                 self.populate_pending_orders()
                 self.populate_completed_orders()
                 if self.selected_order_id:
@@ -4153,182 +4176,279 @@ class MainWindow(QMainWindow):
         if not headers or not isinstance(aggregated, list):
             return
         table_widget.setRowCount(len(aggregated))
         for row_idx, entry in enumerate(aggregated):
             values = self._build_history_row_values(entry)
             for col_idx, value in enumerate(values):
                 item = QTableWidgetItem(str(value))
                 if headers[col_idx] in {"Orden", "Edad", "F. Nacimiento", "Sexo", "Tipo de seguro", "FUA", "Gestación"}:
                     item.setTextAlignment(Qt.AlignCenter)
                 table_widget.setItem(row_idx, col_idx, item)
     def _calculate_age_years(self, patient_info, order_info):
         age_value = order_info.get('age_years') if isinstance(order_info, dict) else None
         if age_value is not None:
             try:
                 return int(age_value)
             except (TypeError, ValueError):
                 age_value = None
         if age_value is None:
             birth_date = patient_info.get('birth_date') if isinstance(patient_info, dict) else None
             if birth_date:
                 bd = QDate.fromString(birth_date, "yyyy-MM-dd")
                 if bd.isValid():
                     age_value = bd.daysTo(QDate.currentDate()) // 365
         return age_value
     def _format_age_text(self, patient_info, order_info):
-        age_value = self._calculate_age_years(patient_info, order_info)
+        age_value = self._calculate_age_years_float(patient_info, order_info)
         return f"{age_value} años" if age_value is not None else "-"
 
+    def _calculate_age_years_float(self, patient_info, order_info):
+        age_value = self._calculate_age_years(patient_info, order_info)
+        if age_value is not None:
+            try:
+                return float(age_value)
+            except (TypeError, ValueError):
+                pass
+        birth_date = patient_info.get('birth_date') if isinstance(patient_info, dict) else None
+        order_date = order_info.get('date') if isinstance(order_info, dict) else None
+        if not birth_date:
+            return None
+        try:
+            birth_dt = datetime.datetime.strptime(str(birth_date), "%Y-%m-%d")
+            if order_date:
+                try:
+                    ref_dt = datetime.datetime.strptime(str(order_date), "%Y-%m-%d %H:%M:%S")
+                except Exception:
+                    ref_dt = datetime.datetime.now()
+            else:
+                ref_dt = datetime.datetime.now()
+            days = (ref_dt.date() - birth_dt.date()).days
+            if days < 0:
+                return None
+            return days / 365.25
+        except Exception:
+            return None
+
+    def get_reference(self, test_name, age_years, sex, is_pregnant):
+        field_ref = None
+        if test_name and isinstance(test_name, str):
+            template = TEST_TEMPLATES.get(test_name)
+            if template and isinstance(template.get("fields"), list):
+                for field_def in template.get("fields", []):
+                    if field_def.get("reference"):
+                        field_ref = field_def.get("reference")
+                        break
+            elif "\n" in test_name or "|" in test_name:
+                field_ref = test_name
+        if not field_ref:
+            return "-"
+        ctx = {
+            "patient": {"sex": sex, "is_pregnant": is_pregnant},
+            "order": {"age_years": age_years}
+        }
+        return self._filter_reference_for_context(field_ref, ctx)
+
+    def _default_sample_type_for_test(self, test_name):
+        normalized = self._normalize_text(test_name)
+        for key, default_value in SAMPLE_TYPE_DEFAULTS.items():
+            if key in normalized:
+                return default_value
+        if "orina" in normalized or "ego" in normalized:
+            return "Orina de chorro medio"
+        return "Muestra estándar"
+
     def _get_field_reference(self, field_def, context=None):
         if not field_def:
             return None
         reference = field_def.get("reference")
         if not reference:
             return reference
         effective_context = context or self.current_order_context
-        return self._filter_reference_for_context(reference, effective_context)
+        patient_info = effective_context.get("patient", {}) if isinstance(effective_context, dict) else {}
+        order_info = effective_context.get("order", {}) if isinstance(effective_context, dict) else {}
+        age_value = self._calculate_age_years_float(patient_info, order_info)
+        sex_text = patient_info.get("sex", "")
+        is_pregnant = self._normalize_bool(patient_info.get("is_pregnant"))
+        return self.get_reference(reference, age_value, sex_text, is_pregnant)
 
     def _filter_reference_for_context(self, reference, context):
         if not reference or not isinstance(reference, str):
             return reference
         if not context:
             return reference
         patient_info = context.get("patient", {}) if isinstance(context, dict) else {}
         order_info = context.get("order", {}) if isinstance(context, dict) else {}
         age_value = self._calculate_age_years(patient_info, order_info)
         sex_text = self._normalize_text(patient_info.get("sex", ""))
+        is_pregnant = self._normalize_bool(patient_info.get("is_pregnant"))
         segments = self._split_reference_segments(reference)
         applicable = []
+        sex_only_matches = []
+        group_only_matches = []
         general_segments = []
         for segment in segments:
             classification = self._classify_reference_segment(segment)
-            if self._segment_matches_context(classification, age_value, sex_text):
-                applicable.append(segment.strip())
-            elif not classification['groups'] and not classification['sexes']:
-                general_segments.append(segment.strip())
+            cleaned_segment = segment.strip()
+            if self._segment_matches_context(classification, age_value, sex_text, is_pregnant):
+                applicable.append(cleaned_segment)
+                continue
+            if self._segment_matches_sex(classification.get('sexes', set()), sex_text):
+                sex_only_matches.append(cleaned_segment)
+            if self._segment_matches_group_only(classification, age_value, is_pregnant):
+                group_only_matches.append(cleaned_segment)
+            if not classification['groups'] and not classification['sexes']:
+                general_segments.append(cleaned_segment)
         if applicable:
-            return "\n".join(applicable)
+            return applicable[0]
+        if sex_only_matches:
+            return sex_only_matches[0]
+        if group_only_matches:
+            return group_only_matches[0]
         if general_segments:
-            return "\n".join(general_segments)
-        return reference
+            return general_segments[0]
+        return segments[0].strip() if segments else reference
 
     def _split_reference_segments(self, reference_text):
         segments = []
         for raw_line in str(reference_text).split('\n'):
             for part in raw_line.split('|'):
                 cleaned = part.strip()
                 if cleaned:
                     segments.append(cleaned)
         return segments or [str(reference_text).strip()]
 
     def _normalize_text(self, text):
         if not isinstance(text, str):
             text = str(text or "")
         normalized = unicodedata.normalize("NFD", text.lower())
         return "".join(ch for ch in normalized if unicodedata.category(ch) != 'Mn')
 
     def _classify_reference_segment(self, segment):
         normalized = self._normalize_text(segment)
         groups = set()
         sexes = set()
         ranges = []
         if any(keyword in normalized for keyword in ["rn", "recien nacido", "neon", "lactant"]):
             groups.add('newborn')
         if any(keyword in normalized for keyword in ["nino", "ninos", "infantil", "pediatr", "menor", "adolesc"]):
             groups.add('child')
         if "mes" in normalized:
             groups.add('child')
         if any(keyword in normalized for keyword in ["adulto", "adultos", "mayor", "ancian", "geriatr"]):
             groups.add('adult')
         if any(keyword in normalized for keyword in ["mujer", "mujeres", "femen"]):
             sexes.add('female')
             groups.add('adult')
         if any(keyword in normalized for keyword in ["hombre", "hombres", "varon", "varones", "mascul"]):
             sexes.add('male')
             groups.add('adult')
         if "gestant" in normalized or "embaraz" in normalized:
             sexes.add('female')
             groups.add('adult')
+            groups.add('pregnant')
         for match in re.finditer(r'(\d+)\s*[-–]\s*(\d+)\s*(?:anos|ano|a)', normalized):
             start = int(match.group(1))
             end = int(match.group(2))
             self._assign_age_range_groups(groups, start, end)
             ranges.append((start, end))
         for match in re.finditer(r'(>=|<=|>|<)?\s*(\d+)\s*(?:anos|ano|a)', normalized):
             operator = match.group(1) or ""
             age = int(match.group(2))
             self._assign_age_range_groups(groups, age, age)
             if operator == '>':
                 ranges.append((age + 0.001, float('inf')))
             elif operator == '>=':
                 ranges.append((age, float('inf')))
             elif operator == '<':
                 ranges.append((float('-inf'), age - 0.001))
             elif operator == '<=':
                 ranges.append((float('-inf'), age))
             else:
                 ranges.append((age, age))
         for match in re.finditer(r'(\d+)\s*(?:mes|meses)', normalized):
             months = int(match.group(1))
             groups.add('child')
             if months <= 1:
                 groups.add('newborn')
             ranges.append((0, max(months / 12, 0)))
         return {"groups": groups, "sexes": sexes, "ranges": ranges}
 
     def _assign_age_range_groups(self, groups, start_age, end_age):
         if end_age < 0 or start_age < 0:
             return
         if end_age >= 18 and start_age >= 18:
             groups.add('adult')
         elif end_age < 18:
             if end_age <= 1:
                 groups.add('newborn')
             groups.add('child')
         else:
             groups.update({'child', 'adult'})
 
-    def _segment_matches_context(self, classification, age_value, normalized_sex):
+    def _segment_matches_context(self, classification, age_value, normalized_sex, is_pregnant=False):
         groups = classification.get('groups', set())
         sexes = classification.get('sexes', set())
         ranges = classification.get('ranges', [])
         if age_value is not None and ranges:
             if not any(self._age_in_range(age_value, start, end) for start, end in ranges):
                 return False
         if age_value is None:
             return self._segment_matches_sex(sexes, normalized_sex)
         target_groups = set()
         if age_value <= 0:
             target_groups.add('newborn')
         if age_value < 18:
             target_groups.add('child')
         if age_value >= 18:
             target_groups.add('adult')
+        if 'pregnant' in groups and not is_pregnant:
+            return False
         if groups and not groups.intersection(target_groups):
             return False
         return self._segment_matches_sex(sexes, normalized_sex)
 
+    def _segment_matches_group_only(self, classification, age_value, is_pregnant=False):
+        groups = classification.get('groups', set())
+        if not groups:
+            return False
+        target_groups = set()
+        if age_value is None:
+            target_groups.update({'child', 'adult', 'newborn'})
+        else:
+            if age_value <= 0:
+                target_groups.add('newborn')
+            if age_value < 18:
+                target_groups.add('child')
+            if age_value >= 18:
+                target_groups.add('adult')
+        if 'pregnant' in groups and not is_pregnant:
+            return False
+        non_preg_groups = {g for g in groups if g != 'pregnant'}
+        if non_preg_groups and not non_preg_groups.intersection(target_groups):
+            return False
+        return True
+
     def _age_in_range(self, age_value, start, end):
         if start is None and end is None:
             return True
         if start is None:
             return age_value <= end
         if end is None:
             return age_value >= start
         return start <= age_value <= end
 
     def _segment_matches_sex(self, sexes, normalized_sex):
         if not sexes:
             return True
         if not normalized_sex:
             return True
         if any(keyword in normalized_sex for keyword in ["femen", "mujer"]):
             return 'female' in sexes
         if any(keyword in normalized_sex for keyword in ["mascul", "hombre", "varon"]):
             return 'male' in sexes
         return True
     def _extract_result_structure(self, test_name, raw_result, context=None):
         parsed = self._parse_stored_result(raw_result)
         template_key = parsed.get("template") if isinstance(parsed, dict) else None
         template = None
         if template_key and template_key in TEST_TEMPLATES:
             template = TEST_TEMPLATES.get(template_key)
@@ -4637,51 +4757,51 @@ class MainWindow(QMainWindow):
                     line += f" ({weeks_text})"
             else:
                 line = 'GESTANTE: NO'
             lines.append(line)
             if due_raw:
                 due_display = self._format_short_date(due_raw)
                 if due_display == '—':
                     due_display = due_raw
                 lines.append(f"FUM: {due_display}")
         lines.append(f"HISTORIA CLÍNICA: {pat.get('hcl') or '-'}")
         lines.append(f"PROCEDENCIA: {pat.get('origin') or '-'}")
         insurance_display = self._format_insurance_display(ord_inf.get('insurance_type'))
         lines.append(f"SEGURO: {insurance_display}")
         requester = ord_inf.get('requested_by') or '-'
         lines.append(f"SOLICITANTE: {requester}")
         emission_raw = ord_inf.get('emitted_at')
         if emission_raw:
             emission_display = self._format_datetime_display(emission_raw, emission_raw)
         else:
             emission_display = "Pendiente de emisión"
         lines.append(f"FECHA DEL INFORME: {emission_display}")
         sample_raw = ord_inf.get('sample_date')
         sample_display = self._format_date_display(sample_raw, "-")
         lines.append(f"FECHA DE TOMA DE MUESTRA: {sample_display}")
         lines.append("RESULTADOS:")
-        for test_name, raw_result, _, sample_status, sample_issue, observation, _, pending_since in results:
+        for test_name, raw_result, _, sample_status, sample_issue, observation, sample_type, _, pending_since in results:
             formatted_lines = self._format_result_lines(test_name, raw_result, context=context)
             if formatted_lines:
                 lines.extend(formatted_lines)
             status_text = self._format_sample_status_text(sample_status, sample_issue, pending_since)
             if status_text:
                 lines.append(f"    Estado de muestra: {status_text}")
             if observation:
                 lines.append(f"    Observación: {observation}")
         if ord_inf["observations"]:
             lines.append(f"Observaciones generales: {ord_inf['observations']}")
         self.output_text.setPlainText("\n".join(lines))
 
 
     def export_pdf(self):
         data = self.combo_completed.currentData()
         if data is None:
             return
         order_id = int(data)
         info = self.labdb.get_order_details(order_id)
         if not info:
             QMessageBox.warning(self, "Orden no disponible", "La orden seleccionada ya no está disponible.")
             self.populate_completed_orders()
             return
         ord_inf = info["order"]
         suggested_name = f"Orden_{order_id}.pdf"
@@ -5057,77 +5177,89 @@ class MainWindow(QMainWindow):
             height += estimate_status_block(status_text, observation_text)
             return height
 
         def estimate_text_height(text_value, status_text, observation_text):
             normalized_text, _ = normalize_styled_text(text_value)
             lines = wrap_text(normalized_text, content_width)
             height = 8.5
             height += max(5.5, len(lines) * 3.6)
             height += estimate_status_block(status_text, observation_text)
             return height
 
         def ensure_test_block_space(required_height):
             if pdf.get_y() + required_height > pdf.h - pdf.b_margin:
                 pdf.add_page()
                 draw_page_header()
 
         def draw_test_header(title):
             ensure_space(9)
             pdf.set_font("Arial", 'B', 8.2)
             pdf.set_text_color(255, 255, 255)
             pdf.set_fill_color(46, 117, 182)
             pdf.cell(0, 6, self._ensure_latin1(title.upper()), ln=1, fill=True)
             pdf.set_text_color(0, 0, 0)
             pdf.ln(1.2)
 
-        for test_name, raw_result, _, sample_status, sample_issue, observation, _, pending_since in results:
+        for test_name, raw_result, _, sample_status, sample_issue, observation, sample_type, _, pending_since in results:
             structure = self._extract_result_structure(test_name, raw_result, context=context)
             if structure.get("type") == "structured":
                 items = structure.get("items", [])
                 if not any(item.get("type") == "value" for item in items):
                     continue
             else:
                 value_text = structure.get("value", "")
                 if isinstance(value_text, str):
                     if value_text.strip() == "":
                         continue
                 elif self._is_blank_result(value_text):
                     continue
 
             status_text = self._format_sample_status_text(sample_status, sample_issue, pending_since)
             observation_text = observation or ""
 
             if structure.get("type") == "structured":
                 required_height = estimate_structured_height(structure.get("items", []), status_text, observation_text)
             else:
                 required_height = estimate_text_height(structure.get("value", ""), status_text, observation_text)
 
             ensure_test_block_space(required_height)
             draw_test_header(test_name)
+            sample_text = (sample_type or "").strip() if isinstance(sample_type, str) else ""
+            if not sample_text:
+                sample_text = self._default_sample_type_for_test(test_name)
+            ensure_space(4.8)
+            pdf.set_font("Arial", 'B', 6.9)
+            pdf.set_text_color(67, 91, 114)
+            pdf.cell(0, 3.8, self._ensure_latin1(f"MUESTRA: {sample_text}"), ln=1)
+            pdf.set_text_color(0, 0, 0)
 
             def on_new_page():
                 draw_test_header(test_name)
+                pdf.set_font("Arial", 'B', 6.9)
+                pdf.set_text_color(67, 91, 114)
+                pdf.cell(0, 3.8, self._ensure_latin1(f"MUESTRA: {sample_text}"), ln=1)
+                pdf.set_text_color(0, 0, 0)
 
             if structure.get("type") == "structured":
                 render_table_header(column_widths, on_new_page)
                 for item in structure.get("items", []):
                     if item.get("type") == "section":
                         render_section_row(item.get("label", ""), sum(column_widths), column_widths, on_new_page)
                         continue
                     row_texts = [
                         item.get('label', ''),
                         item.get('value', '-'),
                         item.get('reference') or '-'
                     ]
                     render_table_row(row_texts, column_widths, on_new_page)
             else:
                 text_value = structure.get("value", "")
                 ensure_space(6)
                 normalized_text, is_italic = normalize_styled_text(text_value)
                 pdf.set_font("Arial", 'I' if is_italic else '', 7)
                 pdf.multi_cell(0, 3.8, self._ensure_latin1(normalized_text))
             if status_text:
                 ensure_space(5)
                 pdf.set_font("Arial", 'I', 6.6)
                 pdf.set_text_color(166, 38, 38)
                 pdf.multi_cell(0, 3.8, self._ensure_latin1(f"Estado de muestra: {status_text}"))
                 pdf.set_text_color(0, 0, 0)
 
EOF
)