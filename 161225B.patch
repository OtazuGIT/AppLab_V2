diff --git a/main_window.py b/main_window.py
index 21d159c832d8407df5937a4d852de81170777556..6a84c92d6c78758a1179ba6254bd5b5930b945bd 100644
--- a/main_window.py
+++ b/main_window.py
@@ -4221,52 +4221,52 @@ class MainWindow(QMainWindow):
         if existing_emission:
             reply = QMessageBox.question(
                 self,
                 "Emitido previamente",
                 "El informe ya fue emitido anteriormente. ¿Desea generar una copia?",
                 QMessageBox.Yes | QMessageBox.No
             )
             if reply == QMessageBox.No:
                 return
             emission_timestamp = ord_inf.get('emitted_at')
             try:
                 emission_dt = datetime.datetime.strptime(emission_timestamp, "%Y-%m-%d %H:%M:%S")
                 emission_display = emission_dt.strftime("%d/%m/%Y %H:%M")
             except Exception:
                 emission_display = emission_timestamp or "-"
             copy_time = datetime.datetime.now()
             print_display = copy_time.strftime("%d/%m/%Y %H:%M")
             is_copy = True
         else:
             mark_as_emitted = True
             emission_time = datetime.datetime.now()
             emission_timestamp = emission_time.strftime("%Y-%m-%d %H:%M:%S")
             emission_display = emission_time.strftime("%d/%m/%Y %H:%M")
             print_display = emission_display
         pdf = FPDF('P', 'mm', 'A4')
-        pdf.set_margins(12, 12, 12)
-        pdf.set_auto_page_break(True, margin=14)
+        pdf.set_margins(10, 8, 10)
+        pdf.set_auto_page_break(True, margin=10)
         pdf.add_page()
         self._render_order_pdf(
             pdf,
             info,
             emission_display,
             print_display=print_display,
             is_copy=is_copy
         )
         try:
             pdf.output(file_path)
         except Exception as exc:
             QMessageBox.warning(self, "Error", f"No se pudo guardar el PDF:\n{exc}")
             return
         if mark_as_emitted:
             self.labdb.mark_order_emitted(order_id, emission_timestamp)
         QMessageBox.information(self, "Informe emitido", f"Reporte guardado en:\n{file_path}")
         self.populate_completed_orders()
         self.output_text.clear()
 
     def _render_order_pdf(self, pdf, info, emission_display, print_display=None, is_copy=False):
         pat = info["patient"]
         ord_inf = info["order"]
         results = info["results"]
         context = {"patient": pat, "order": ord_inf}
         doc_text = " ".join([part for part in (pat.get('doc_type'), pat.get('doc_number')) if part]) or "-"
@@ -4390,261 +4390,290 @@ class MainWindow(QMainWindow):
                         header_drawn = True
                     except Exception:
                         header_drawn = False
             if not header_drawn:
                 pdf.set_y(pdf.t_margin)
                 pdf.set_font("Arial", 'B', 12)
                 pdf.cell(0, 6, self._ensure_latin1(LAB_TITLE), ln=1, align='C')
                 pdf.ln(2)
             draw_patient_info()
             pdf.ln(1.0)
             if is_copy:
                 copy_note = f"Copia reimpresa el {print_display}" if print_display else "Copia reimpresa"
                 pdf.set_font("Arial", 'B', 8.5)
                 pdf.set_text_color(110, 110, 110)
                 pdf.cell(0, 4, self._ensure_latin1(copy_note), ln=1, align='R')
                 pdf.set_text_color(0, 0, 0)
                 pdf.ln(0.5)
 
         def ensure_space(required_height):
             if pdf.get_y() + required_height > pdf.h - pdf.b_margin:
                 pdf.add_page()
                 draw_page_header()
                 return True
             return False
 
+        def normalize_styled_text(text):
+            if text in (None, ""):
+                return "-", False
+            if not isinstance(text, str):
+                return text, False
+            stripped = text.strip()
+            if len(stripped) >= 2 and stripped[0] in {"*", "_"} and stripped[-1] == stripped[0]:
+                inner = stripped[1:-1].strip()
+                if inner:
+                    return inner, True
+            return text, False
+
         def wrap_text(text, max_width):
             if max_width <= 0:
                 return [str(text)]
             if text in (None, ""):
                 text = "-"
             text = self._ensure_latin1(str(text)).replace('\r', ' ')
             segments = []
             for part in text.split('\n'):
                 stripped = part.strip()
                 if stripped:
                     segments.append(stripped)
             if not segments:
                 segments = [text.strip() or "-"]
             lines = []
             for segment in segments:
                 words = segment.split()
                 if not words:
                     lines.append("-")
                     continue
                 current = words[0]
                 for word in words[1:]:
                     candidate = f"{current} {word}"
                     if pdf.get_string_width(candidate) <= max(max_width, 1):
                         current = candidate
                     else:
                         lines.append(current)
                         current = word
                 lines.append(current)
             return lines or ["-"]
 
         def render_table_header(widths, on_new_page=None):
-            header_height = 6
+            header_height = 5.6
             if ensure_space(header_height) and on_new_page:
                 on_new_page()
                 ensure_space(header_height)
             pdf.set_font("Arial", 'B', 7.2)
-            pdf.set_text_color(255, 255, 255)
-            pdf.set_fill_color(46, 117, 182)
             x_start = pdf.l_margin
             pdf.set_x(x_start)
             headers = ["Parámetro", "Resultado", "Valores de referencia"]
             for idx, title in enumerate(headers):
+                if idx == 2:
+                    pdf.set_fill_color(220, 220, 220)
+                    pdf.set_text_color(50, 50, 50)
+                else:
+                    pdf.set_fill_color(46, 117, 182)
+                    pdf.set_text_color(255, 255, 255)
                 pdf.cell(widths[idx], header_height, self._ensure_latin1(title), border=1, align='C', fill=True)
             pdf.ln(header_height)
             pdf.set_text_color(0, 0, 0)
 
         def render_table_row(texts, widths, on_new_page):
-            line_height = 3.4
-            padding_x = 1.4
-            padding_y = 0.9
+            line_height = 3.1
+            padding_x = 1.3
+            padding_y = 0.8
             pdf.set_font("Arial", '', 6.8)
             lines_by_cell = []
             max_lines = 1
             for idx, text in enumerate(texts):
                 available = max(widths[idx] - 2 * padding_x, 1)
-                lines = wrap_text(text, available)
-                lines_by_cell.append(lines)
+                normalized, is_italic = normalize_styled_text(text)
+                lines = wrap_text(normalized, available)
+                lines_by_cell.append((lines, is_italic))
                 if len(lines) > max_lines:
                     max_lines = len(lines)
             row_height = max_lines * line_height + 2 * padding_y
             if ensure_space(row_height):
                 on_new_page()
                 render_table_header(widths, on_new_page)
             x_start = pdf.l_margin
             y_start = pdf.get_y()
             pdf.set_draw_color(210, 215, 226)
             pdf.set_line_width(0.2)
-            for idx, lines in enumerate(lines_by_cell):
+            for idx, (lines, is_italic) in enumerate(lines_by_cell):
                 cell_width = widths[idx]
                 x_pos = x_start + sum(widths[:idx])
-                pdf.set_fill_color(255, 255, 255)
+                if idx == 2:
+                    pdf.set_fill_color(245, 245, 245)
+                    pdf.set_text_color(70, 70, 70)
+                else:
+                    pdf.set_fill_color(255, 255, 255)
+                    pdf.set_text_color(0, 0, 0)
                 pdf.rect(x_pos, y_start, cell_width, row_height)
                 text_y = y_start + padding_y
                 for line in lines:
                     line = self._ensure_latin1(line)
                     pdf.set_xy(x_pos + padding_x, text_y)
+                    pdf.set_font("Arial", 'I' if is_italic else '', 6.8)
                     pdf.cell(cell_width - 2 * padding_x, line_height, line, border=0)
                     text_y += line_height
+            pdf.set_text_color(0, 0, 0)
             pdf.set_xy(pdf.l_margin, y_start + row_height)
 
         def render_section_row(label, total_width, widths, on_new_page):
             section_height = 4.2
             if ensure_space(section_height + 1):
                 on_new_page()
                 render_table_header(widths, on_new_page)
             pdf.set_font("Arial", 'B', 6.8)
             pdf.set_fill_color(242, 246, 253)
             pdf.set_text_color(47, 84, 150)
             pdf.cell(total_width, section_height, self._ensure_latin1(label), border=1, ln=1, align='L', fill=True)
             pdf.set_text_color(0, 0, 0)
 
         draw_page_header()
 
         table_total_width = pdf.w - pdf.l_margin - pdf.r_margin
         column_widths = [table_total_width * 0.38, table_total_width * 0.27, table_total_width * 0.35]
         content_width = table_total_width
 
         def estimate_table_row_height(texts, widths):
-            line_height = 3.4
-            padding_x = 1.4
-            padding_y = 0.9
+            line_height = 3.1
+            padding_x = 1.3
+            padding_y = 0.8
             max_lines = 1
             for idx, text in enumerate(texts):
                 available = max(widths[idx] - 2 * padding_x, 1)
-                lines = wrap_text(text, available)
+                normalized, _ = normalize_styled_text(text)
+                lines = wrap_text(normalized, available)
                 if len(lines) > max_lines:
                     max_lines = len(lines)
             return max_lines * line_height + 2 * padding_y
 
         def estimate_status_block(status_text, observation_text):
             height = 2
             if status_text:
                 status_lines = wrap_text(status_text, content_width)
                 height += max(5, len(status_lines) * 3.8)
             if observation_text:
-                obs_lines = wrap_text(observation_text, content_width)
+                normalized_obs, _ = normalize_styled_text(observation_text)
+                obs_lines = wrap_text(normalized_obs, content_width)
                 height += max(5, len(obs_lines) * 3.8)
             return height
 
         def estimate_structured_height(items, status_text, observation_text):
-            height = 9  # cabecera de prueba
-            height += 6  # cabecera de tabla
+            height = 8.5  # cabecera de prueba
+            height += 5.6  # cabecera de tabla
             for item in items:
                 if item.get("type") == "section":
                     height += 5.2
                     continue
                 row_texts = [
                     item.get('label', ''),
                     item.get('value', '-'),
                     item.get('reference') or '-'
                 ]
                 height += estimate_table_row_height(row_texts, column_widths)
             height += estimate_status_block(status_text, observation_text)
             return height
 
         def estimate_text_height(text_value, status_text, observation_text):
-            lines = wrap_text(text_value, content_width)
-            height = 9
-            height += max(6, len(lines) * 4)
+            normalized_text, _ = normalize_styled_text(text_value)
+            lines = wrap_text(normalized_text, content_width)
+            height = 8.5
+            height += max(5.5, len(lines) * 3.6)
             height += estimate_status_block(status_text, observation_text)
             return height
 
         def ensure_test_block_space(required_height):
             if pdf.get_y() + required_height > pdf.h - pdf.b_margin:
                 pdf.add_page()
                 draw_page_header()
 
         def draw_test_header(title):
             ensure_space(9)
-            pdf.set_font("Arial", 'B', 8.6)
+            pdf.set_font("Arial", 'B', 8.2)
             pdf.set_text_color(255, 255, 255)
             pdf.set_fill_color(46, 117, 182)
             pdf.cell(0, 6, self._ensure_latin1(title.upper()), ln=1, fill=True)
             pdf.set_text_color(0, 0, 0)
             pdf.ln(1.2)
 
         for test_name, raw_result, _, sample_status, sample_issue, observation, _, pending_since in results:
             structure = self._extract_result_structure(test_name, raw_result, context=context)
             if structure.get("type") == "structured":
                 items = structure.get("items", [])
                 if not any(item.get("type") == "value" for item in items):
                     continue
             else:
                 value_text = structure.get("value", "")
                 if isinstance(value_text, str):
                     if value_text.strip() == "":
                         continue
                 elif self._is_blank_result(value_text):
                     continue
 
             status_text = self._format_sample_status_text(sample_status, sample_issue, pending_since)
             observation_text = observation or ""
 
             if structure.get("type") == "structured":
                 required_height = estimate_structured_height(structure.get("items", []), status_text, observation_text)
             else:
                 required_height = estimate_text_height(structure.get("value", ""), status_text, observation_text)
 
             ensure_test_block_space(required_height)
             draw_test_header(test_name)
 
             def on_new_page():
                 draw_test_header(test_name)
 
             if structure.get("type") == "structured":
                 render_table_header(column_widths, on_new_page)
                 for item in structure.get("items", []):
                     if item.get("type") == "section":
                         render_section_row(item.get("label", ""), sum(column_widths), column_widths, on_new_page)
                         continue
                     row_texts = [
                         item.get('label', ''),
                         item.get('value', '-'),
                         item.get('reference') or '-'
                     ]
                     render_table_row(row_texts, column_widths, on_new_page)
             else:
                 text_value = structure.get("value", "")
                 ensure_space(6)
-                pdf.set_font("Arial", '', 7)
-                pdf.multi_cell(0, 4, self._ensure_latin1(text_value))
+                normalized_text, is_italic = normalize_styled_text(text_value)
+                pdf.set_font("Arial", 'I' if is_italic else '', 7)
+                pdf.multi_cell(0, 3.8, self._ensure_latin1(normalized_text))
             if status_text:
                 ensure_space(5)
                 pdf.set_font("Arial", 'I', 6.6)
                 pdf.set_text_color(166, 38, 38)
                 pdf.multi_cell(0, 3.8, self._ensure_latin1(f"Estado de muestra: {status_text}"))
                 pdf.set_text_color(0, 0, 0)
             if observation_text:
                 ensure_space(5)
-                pdf.set_font("Arial", 'I', 6.6)
-                pdf.multi_cell(0, 3.8, self._ensure_latin1(f"Observación: {observation_text}"))
+                normalized_obs, is_obs_italic = normalize_styled_text(observation_text)
+                pdf.set_font("Arial", 'I' if is_obs_italic else '', 6.6)
+                pdf.multi_cell(0, 3.8, self._ensure_latin1(f"Observación: {normalized_obs}"))
             pdf.ln(2)
 
         if ord_inf.get('observations') and str(ord_inf['observations']).strip().upper() not in {"", "N/A"}:
             ensure_space(8)
             pdf.set_font("Arial", 'B', 7.4)
             pdf.cell(0, 4.2, "Observaciones generales", ln=1)
             pdf.set_font("Arial", '', 6.9)
             pdf.multi_cell(0, 3.6, self._ensure_latin1(ord_inf['observations']))
             pdf.ln(1.5)
 
     def export_pdf_batch(self):
         orders = getattr(self, 'completed_orders_cache', [])
         if not orders:
             QMessageBox.information(self, "Sin órdenes", "No hay órdenes completadas para emitir.")
             return
         options = []
         for order in orders:
             option = {
                 "id": order["id"],
                 "display": self._format_order_display(order),
                 "preselect": not order.get("emitted"),
                 "emitted": order.get("emitted")
             }
             options.append(option)
         dialog = BatchEmitDialog(options, self)
